<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Tutorial &#8212; vegas 6.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=4848ba22" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css?v=310c80ee" />
    <script src="_static/documentation_options.js?v=808ed8c8"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Compiled Integrands for Speed; GPUs" href="compiled_integrands.html" />
    <link rel="prev" title="vegas Documentation" href="index.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="compiled_integrands.html" title="Compiled Integrands for Speed; GPUs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="vegas Documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">vegas 6.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tutorial</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Class <a class="reference internal" href="vegas.html#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a> gives Monte Carlo estimates of arbitrary
multidimensional integrals using the <em>vegas</em> algorithm
(G. P. Lepage, J. Comput. Phys. 27 (1978) 192 and J. Comput. Phys. 439 (2021) 110386).
The algorithm has two components.
First an automatic transformation is applied to to the integration variables
in an attempt to flatten the integrand. Then a Monte Carlo estimate of the
integral is made using the  transformed variables. Flattening the integrand
makes the integral easier and improves the estimate.  The transformation
applied to the integration variables is optimized
over several iterations of the algorithm: information about the integrand that
is collected during one iteration is used to  improve the transformation used
in the next iteration.</p>
<p>Monte Carlo integration makes few assumptions about the
integrand — it needn’t be analytic nor even continuous. This
makes Monte Carlo integration unusually robust. It also makes it well suited
for adaptive integration. Adaptive strategies are essential for
multidimensional integration, especially in high dimensions, because
multidimensional space is large, with  lots of corners, making it
easy to lose important features in the integrand.</p>
<p>Monte Carlo integration also provides efficient and reliable methods for
estimating the
accuracy of its results. In particular, each Monte Carlo
estimate of an integral is a random number from a distribution
whose mean is the correct value of the integral. This distribution is
Gaussian or normal provided
the number of integrand samples is sufficiently large.
In practice we generate multiple
estimates of the integral
in order to verify that the distribution is indeed Gaussian.
Error analysis is straightforward if the
integral estimates are Gaussian.</p>
<p>The <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> algorithm has been in use for decades and implementations are
available in many programming languages, including Fortran (the original
version), C and C++. The algorithm used here is significantly improved over
the original implementation, and that used in most other implementations.
It uses two adaptive strategies: importance sampling, as in the original
implementation, and adaptive stratified sampling, which is new. The
new algorithm is described in G. P. Lepage, <a class="reference external" href="https://arxiv.org/abs/2009.05112">arXiv_2009.05112</a>
(J. Comput. Phys. 439 (2021) 110386).</p>
<p>There is also a third adaptive strategy, adaptive re-stratification, that can
be useful in very high dimensions. See <a class="reference internal" href="vegas.html#vegas.restratify" title="vegas.restratify"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.restratify()</span></code></a>.</p>
<p>This module is written in Cython, so it is almost as fast as compiled Fortran or
C, particularly when the integrand is also coded in Cython (or some other
compiled language), as discussed below.</p>
<p>The following sections describe how to use <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>. Almost every
example shown is a complete code, which can be copied into a file
and run with Python. It is worthwhile playing with the parameters to see how
things change.</p>
<p><em>About Printing:</em> The examples in this tutorial use the print function as it is
used in Python 3. Drop the outermost parenthesis in each print statement if
using Python 2, or add</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</pre></div>
</div>
<p>at the start of your file.</p>
</section>
<section id="basic-integrals">
<span id="id1"></span><h2>Basic Integrals<a class="headerlink" href="#basic-integrals" title="Link to this heading">¶</a></h2>
<p>Here we illustrate the use of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> by estimating the integral</p>
<div class="math">
<p><img src="_images/math/1de84d848233a3579b11f49f5374847fcac94175.svg" alt="C\int_{-1}^1 dx_0 \int_0^1 dx_1 \int_0^1 dx_2 \int_0^1 dx_3
\,\,\mathrm{e}^{- 100 \sum_{d}(x_d-0.5)^2}  ,"/></p>
</div><p>where constant <img class="math" src="_images/math/541256ca21ce44accc931671c333e351d880f8c9.svg" alt="C"/> is chosen so that the exact integral is 1.
The following code shows how this can be done:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1013.2118364296088</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>First we define the integrand <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> where <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> specifies a  point in the
4-dimensional space. We then create an  integrator, <code class="docutils literal notranslate"><span class="pre">integ</span></code>, which is an
integration operator  that can be applied to any 4-dimensional function. It is
where we specify the integration volume.
Finally we apply <code class="docutils literal notranslate"><span class="pre">integ</span></code> to our integrand <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>,
telling the integrator to estimate  the integral using <code class="docutils literal notranslate"><span class="pre">nitn=10</span></code> iterations
of the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> algorithm, each of which uses no more than <code class="docutils literal notranslate"><span class="pre">neval=1000</span></code>
evaluations of the integrand. Each iteration produces an independent
estimate of the integral. The final estimate is the weighted average of
the results from all 10 iterations, and is returned by <code class="docutils literal notranslate"><span class="pre">integ(f</span> <span class="pre">...)</span></code>.
The call <code class="docutils literal notranslate"><span class="pre">result.summary()</span></code> returns
a summary of results from each iteration.</p>
<p>This code produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">2.6</span><span class="p">(</span><span class="mf">1.4</span><span class="p">)</span>        <span class="mf">2.6</span><span class="p">(</span><span class="mf">1.4</span><span class="p">)</span>            <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.32</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>        <span class="mf">1.36</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>            <span class="mf">0.75</span>     <span class="mf">0.39</span>
  <span class="mi">3</span>   <span class="mf">0.909</span><span class="p">(</span><span class="mi">96</span><span class="p">)</span>       <span class="mf">0.968</span><span class="p">(</span><span class="mi">89</span><span class="p">)</span>           <span class="mf">1.79</span>     <span class="mf">0.17</span>
  <span class="mi">4</span>   <span class="mf">1.039</span><span class="p">(</span><span class="mi">69</span><span class="p">)</span>       <span class="mf">1.012</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>           <span class="mf">1.32</span>     <span class="mf">0.26</span>
  <span class="mi">5</span>   <span class="mf">0.929</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span>       <span class="mf">0.952</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>           <span class="mf">1.41</span>     <span class="mf">0.23</span>
  <span class="mi">6</span>   <span class="mf">1.003</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>       <span class="mf">0.980</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>           <span class="mf">1.47</span>     <span class="mf">0.20</span>
  <span class="mi">7</span>   <span class="mf">0.994</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">0.988</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>           <span class="mf">1.27</span>     <span class="mf">0.27</span>
  <span class="mi">8</span>   <span class="mf">0.998</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>       <span class="mf">0.9922</span><span class="p">(</span><span class="mi">98</span><span class="p">)</span>          <span class="mf">1.13</span>     <span class="mf">0.34</span>
  <span class="mi">9</span>   <span class="mf">1.020</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>       <span class="mf">1.0035</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>          <span class="mf">1.39</span>     <span class="mf">0.20</span>
 <span class="mi">10</span>   <span class="mf">1.011</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>       <span class="mf">1.0057</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>          <span class="mf">1.27</span>     <span class="mf">0.25</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">1.0057</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.25</span>
</pre></div>
</div>
<p>There are several things to note here:</p>
<blockquote>
<div><p><strong>Adaptation:</strong> Integration estimates are shown for
each of the 10 iterations,
giving both the estimate from just that iteration, and the weighted
average of results from all iterations up to that point.  The
estimates from the first two iterations are not accurate at
all, with errors equal to 25–140% of the final result.
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> initially has no information about the integrand
and so does a relatively poor job of estimating the integral.
It uses information from the samples in one iteration, however,
to remap the integration variables for subsequent iterations,
concentrating samples where the function is largest and reducing
errors.
As a result, the per-iteration error
is reduced to 3.4% by the fifth iteration, and almost to 1% by
the end — an improvement by a factor of more than 100 from the start.
Eventually the per-iteration error
stops decreasing because <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> has found the optimal remapping,
at which point
it is fully adapted to the integrand.</p>
<p><strong>Weighted Average:</strong> The final result, 1.0057 ± 0.0064,
is obtained from a weighted
average of the separate results from each iteration:
estimates are weighted by the inverse variance, thereby giving
much less weight to the early iterations, where the errors are
largest.
The individual estimates are statistical: each
is a random number drawn from a distribution whose mean
equals the correct value of the integral, and the errors
quoted are estimates of the standard deviations of those
distributions. The distributions are Gaussian provided
the number of integrand evaluations per iteration (<code class="docutils literal notranslate"><span class="pre">neval</span></code>)
is sufficiently large, in which case the standard deviation
is a reliable estimate of the error.
The weighted average <img class="math" src="_images/math/541ec0b3e8c34fb06a019a0c31afa46d205fb6b0.svg" alt="\overline I"/>  minimizes</p>
<div class="math">
<p><img src="_images/math/d0270c264a170737153cccd5c2a81d2acf368eb5.svg" alt="\chi^2 \,\equiv\, \sum_i \frac{(I_i - \overline I)^2}{\sigma_{i}^2}"/></p>
</div><p>where <img class="math" src="_images/math/0b7d38e075070ef753add582d1ca8c184ab85dba.svg" alt="I_i \pm \sigma_{i}"/> are the estimates from
individual iterations. If the <img class="math" src="_images/math/e797e95faec2f60bcc2d604fc4b6383d75edd688.svg" alt="I_i"/> are Gaussian,
<img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> should be of order the number of degrees of
freedom (plus or minus the square root of double that number);
here the number of degrees of freedom is the number of
iterations minus 1.</p>
<p>The distributions are likely non-Gaussian, and error estimates
unreliable, if <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> is
much larger than the number of iterations. This criterion is quantified
by the <em>Q</em> or <em>p-value</em> of the <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/>,
which is the probability that a
larger <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> could result from random (Gaussian)
fluctuations. A very small <em>Q</em> (less than 0.05-0.1) indicates
that the <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> is too large to be accounted for by
statistical fluctuations — that is, the estimates of the integral
from different iterations do not agree with each other to
within errors. This means that <code class="docutils literal notranslate"><span class="pre">neval</span></code> is not sufficiently
large to guarantee Gaussian behavior, and must be increased
if the error estimates are to be trusted.</p>
<p><code class="docutils literal notranslate"><span class="pre">integ(f...)</span></code> returns a weighted-average object,
of type <a class="reference internal" href="vegas.html#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvg</span></code></a>, that has the following
attributes:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">result.mean</span></code> — weighted average of all estimates of the integral;</p>
<p><code class="docutils literal notranslate"><span class="pre">result.sdev</span></code> — standard deviation of the weighted average;</p>
<p><code class="docutils literal notranslate"><span class="pre">result.chi2</span></code> — <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> of the weighted average;</p>
<p><code class="docutils literal notranslate"><span class="pre">result.dof</span></code> — number of degrees of freedom;</p>
<p><code class="docutils literal notranslate"><span class="pre">result.Q</span></code> — <em>Q</em> or <em>p-value</em> of the weighted average’s <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/>;</p>
<p><code class="docutils literal notranslate"><span class="pre">result.itn_results</span></code> — list of the integral estimates from each iteration;</p>
<p><code class="docutils literal notranslate"><span class="pre">result.sum_neval</span></code> — total number of integrand evaluations used.</p>
<p><code class="docutils literal notranslate"><span class="pre">result.avg_neval</span></code> — average number of integrand evaluations per iteration</p>
</div></blockquote>
<p>In this example the final <em>Q</em> is 0.25, indicating that the
<img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> for this average is not particularly unlikely and
thus the error estimate is likely reliable.</p>
<p><strong>Precision:</strong> The precision of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> estimates is
determined by <code class="docutils literal notranslate"><span class="pre">nitn</span></code>, the number of iterations
of the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> algorithm,
and by <code class="docutils literal notranslate"><span class="pre">neval</span></code>, the maximum number of integrand evaluations
made per iteration.
The computing cost is typically proportional to the
product of <code class="docutils literal notranslate"><span class="pre">nitn</span></code> and <code class="docutils literal notranslate"><span class="pre">neval</span></code>.
The number of integrand
evaluations per iteration
varies from iteration to iteration,
here between 860 and 960. Typically <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> needs more
integration points in early iterations, before it has fully
adapted to the integrand.</p>
<p>We can increase precision by increasing either <code class="docutils literal notranslate"><span class="pre">nitn</span></code> or <code class="docutils literal notranslate"><span class="pre">neval</span></code>,
but it is
generally far better to increase <code class="docutils literal notranslate"><span class="pre">neval</span></code>. For example,
adding the following lines to the code above</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;larger nitn  =&gt; </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">1e4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;larger neval =&gt; </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>generates the following results:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">larger</span> <span class="n">nitn</span>  <span class="o">=&gt;</span> <span class="mf">1.0003</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.79</span>
<span class="n">larger</span> <span class="n">neval</span> <span class="o">=&gt;</span> <span class="mf">0.99981</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.28</span>
</pre></div>
</div>
<p>The total number of integrand evaluations, <code class="docutils literal notranslate"><span class="pre">nitn</span> <span class="pre">*</span> <span class="pre">neval</span></code>, is
about the same in both cases, but increasing <code class="docutils literal notranslate"><span class="pre">neval</span></code> is more
than twice as accurate as increasing <code class="docutils literal notranslate"><span class="pre">nitn</span></code>. Typically you
want to use no more than 10 or 20 iterations beyond the
point where <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> has fully adapted. You want some number of
iterations so that you can verify Gaussian behavior by
checking the <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> and <em>Q</em>, but not too many.</p>
<p>It is also generally useful to compare two or more
results from values of <code class="docutils literal notranslate"><span class="pre">neval</span></code> that differ by a
significant factor (4–10, say). These should agree within
errors. If they do not, it could be due to non-Gaussian
artifacts caused by a small <code class="docutils literal notranslate"><span class="pre">neval</span></code>. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
estimates have two sources of error. One is the statistical
error, which is what is quoted by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>. The other is
a systematic error due to residual non-Gaussian
effects. The systematic error vanishes like
<code class="docutils literal notranslate"><span class="pre">1/neval</span></code> or faster, and so becomes negligible compared with
the statistical error as <code class="docutils literal notranslate"><span class="pre">neval</span></code> increases.
The systematic error can bias the Monte Carlo estimate, however,
if <code class="docutils literal notranslate"><span class="pre">neval</span></code> is insufficiently large. This usually
results in a large <img class="math" src="_images/math/3049b41e4ab6ebe9380f9b54ed1d16b7fda6d45a.svg" alt="\chi^2"/> (and small <em>Q</em>), but a
more reliable check is to compare
results that use significantly different values of <code class="docutils literal notranslate"><span class="pre">neval</span></code>.
The systematic errors due to non-Gaussian behavior are
likely negligible if the different estimates agree to
within the statistical errors.</p>
<p>The possibility of systematic biases
is another reason for increasing <code class="docutils literal notranslate"><span class="pre">neval</span></code>
rather than <code class="docutils literal notranslate"><span class="pre">nitn</span></code> to obtain more precision.
Making <code class="docutils literal notranslate"><span class="pre">neval</span></code> larger and larger is guaranteed
to improve the Monte Carlo estimate, as the statistical
error decreases and the
systematic error decreases even more quickly.
Making <code class="docutils literal notranslate"><span class="pre">nitn</span></code> larger and larger, on the other hand,
is guaranteed eventually to give the wrong
answer. This is because at some point the statistical error
(which falls as <code class="docutils literal notranslate"><span class="pre">sqrt(1/nitn)</span></code>) will no longer
mask the systematic error (which is unaffected by <code class="docutils literal notranslate"><span class="pre">nitn</span></code>).
The systematic error for the integral
above (with <code class="docutils literal notranslate"><span class="pre">neval=1000</span></code>) is about -0.0008, which
is negligible compared to the statistical error unless
<code class="docutils literal notranslate"><span class="pre">nitn</span></code> is of order 1500 or larger — so systematic errors
aren’t a problem with <code class="docutils literal notranslate"><span class="pre">nitn=10</span></code>.</p>
<p><strong>Early Iterations:</strong> Integral estimates from early iterations,
before <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> has adapted, can be quite
crude. With very peaky integrands, these are often far from
the correct answer with highly unreliable error  estimates. For
example, the integral above becomes more
difficult if we double the length of each side of the
integration volume by redefining <code class="docutils literal notranslate"><span class="pre">integ</span></code> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p>The code above then gives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.0011</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>      <span class="mf">0.0011</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>          <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.074</span><span class="p">(</span><span class="mi">56</span><span class="p">)</span>       <span class="mf">0.0011</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>          <span class="mf">1.71</span>     <span class="mf">0.19</span>
  <span class="mi">3</span>   <span class="mf">0.250</span><span class="p">(</span><span class="mi">59</span><span class="p">)</span>       <span class="mf">0.0012</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>          <span class="mf">9.65</span>     <span class="mf">0.00</span>
  <span class="mi">4</span>   <span class="mf">0.93</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>        <span class="mf">0.0013</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>         <span class="mf">21.40</span>     <span class="mf">0.00</span>
  <span class="mi">5</span>   <span class="mf">0.874</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span>       <span class="mf">0.0015</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>         <span class="mf">54.87</span>     <span class="mf">0.00</span>
  <span class="mi">6</span>   <span class="mf">0.949</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>       <span class="mf">0.0021</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>        <span class="mf">162.08</span>     <span class="mf">0.00</span>
  <span class="mi">7</span>   <span class="mf">0.949</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>       <span class="mf">0.0033</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>        <span class="mf">301.18</span>     <span class="mf">0.00</span>
  <span class="mi">8</span>   <span class="mf">0.985</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>       <span class="mf">0.0050</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>        <span class="mf">484.50</span>     <span class="mf">0.00</span>
  <span class="mi">9</span>   <span class="mf">0.967</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>       <span class="mf">0.0078</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>        <span class="mf">738.53</span>     <span class="mf">0.00</span>
 <span class="mi">10</span>   <span class="mf">0.988</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>       <span class="mf">0.0125</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>       <span class="mf">1131.46</span>     <span class="mf">0.00</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">0.0125</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.00</span>
</pre></div>
</div>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> misses the peak completely in the first iteration,
giving an estimate that is completely
wrong (by 1000 standard deviations!).
Some of its samples hit the peak’s shoulders, so <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is
eventually able to find the peak (by iterations 5–6), but
the integrand estimates are wildly non-Gaussian before that
point. This results in a nonsensical final result, as
indicated by the <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0.00</span></code>.</p>
<p>It is common practice in using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to discard
estimates from the first several iterations, before the
algorithm has adapted, in order to avoid ruining the
final result in this way. This is done by replacing the
single call to <code class="docutils literal notranslate"><span class="pre">integ(f...)</span></code> in the original code
with two calls:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># step 1 -- adapt to f; discard results</span>
<span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># step 2 -- integ has adapted to f; keep results</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>The integrator is trained in the first
step, as it adapts to the integrand, and so is more or less
fully adapted from the start in the second step, which yields:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.993</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">0.993</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.062</span><span class="p">(</span><span class="mi">48</span><span class="p">)</span>       <span class="mf">1.001</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>           <span class="mf">1.83</span>     <span class="mf">0.18</span>
  <span class="mi">3</span>   <span class="mf">0.964</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">0.987</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>           <span class="mf">1.91</span>     <span class="mf">0.15</span>
  <span class="mi">4</span>   <span class="mf">0.974</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>       <span class="mf">0.9817</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>          <span class="mf">1.40</span>     <span class="mf">0.24</span>
  <span class="mi">5</span>   <span class="mf">0.990</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>       <span class="mf">0.9843</span><span class="p">(</span><span class="mi">82</span><span class="p">)</span>          <span class="mf">1.10</span>     <span class="mf">0.35</span>
  <span class="mi">6</span>   <span class="mf">1.012</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>       <span class="mf">0.9899</span><span class="p">(</span><span class="mi">73</span><span class="p">)</span>          <span class="mf">1.34</span>     <span class="mf">0.25</span>
  <span class="mi">7</span>   <span class="mf">0.999</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>       <span class="mf">0.9917</span><span class="p">(</span><span class="mi">65</span><span class="p">)</span>          <span class="mf">1.16</span>     <span class="mf">0.32</span>
  <span class="mi">8</span>   <span class="mf">1.008</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>       <span class="mf">0.9953</span><span class="p">(</span><span class="mi">58</span><span class="p">)</span>          <span class="mf">1.20</span>     <span class="mf">0.30</span>
  <span class="mi">9</span>   <span class="mf">1.013</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>       <span class="mf">0.9977</span><span class="p">(</span><span class="mi">54</span><span class="p">)</span>          <span class="mf">1.20</span>     <span class="mf">0.29</span>
 <span class="mi">10</span>   <span class="mf">0.983</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>       <span class="mf">0.9958</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>          <span class="mf">1.17</span>     <span class="mf">0.31</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">0.9958</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.31</span>
</pre></div>
</div>
<p>The final result is now reliable.</p>
<p><strong>Other Integrands:</strong> Once <code class="docutils literal notranslate"><span class="pre">integ</span></code> has been trained on <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>,
it can be usefully applied
to other functions with similar structure. For example, adding
the following at the end of the original code,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>gives the following new output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.4933</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>      <span class="mf">0.4933</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>          <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.5017</span><span class="p">(</span><span class="mi">54</span><span class="p">)</span>      <span class="mf">0.4980</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>          <span class="mf">1.04</span>     <span class="mf">0.31</span>
  <span class="mi">3</span>   <span class="mf">0.4975</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>      <span class="mf">0.4979</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span>          <span class="mf">0.52</span>     <span class="mf">0.59</span>
  <span class="mi">4</span>   <span class="mf">0.5059</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>      <span class="mf">0.4998</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>          <span class="mf">0.80</span>     <span class="mf">0.49</span>
  <span class="mi">5</span>   <span class="mf">0.5075</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>      <span class="mf">0.5012</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>          <span class="mf">0.90</span>     <span class="mf">0.46</span>
  <span class="mi">6</span>   <span class="mf">0.4907</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>      <span class="mf">0.4997</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>          <span class="mf">1.15</span>     <span class="mf">0.33</span>
  <span class="mi">7</span>   <span class="mf">0.5009</span><span class="p">(</span><span class="mi">47</span><span class="p">)</span>      <span class="mf">0.5000</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>          <span class="mf">0.97</span>     <span class="mf">0.45</span>
  <span class="mi">8</span>   <span class="mf">0.5082</span><span class="p">(</span><span class="mi">58</span><span class="p">)</span>      <span class="mf">0.5010</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>          <span class="mf">1.08</span>     <span class="mf">0.38</span>
  <span class="mi">9</span>   <span class="mf">0.5016</span><span class="p">(</span><span class="mi">63</span><span class="p">)</span>      <span class="mf">0.5010</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>          <span class="mf">0.94</span>     <span class="mf">0.48</span>
 <span class="mi">10</span>   <span class="mf">0.4934</span><span class="p">(</span><span class="mi">76</span><span class="p">)</span>      <span class="mf">0.5006</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>          <span class="mf">0.94</span>     <span class="mf">0.49</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">0.5006</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.49</span>
</pre></div>
</div>
<p>Again the grid is almost optimal for <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> from the start,
because <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> peaks in the same region as <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>.
The exact value for this integral is very close to 0.5.</p>
<p><strong>Non-Rectangular Volumes:</strong> <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> can integrate over volumes of
non-rectangular shape. For example, we can replace integrand <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>
above
by the same Gaussian, but restricted to a 4-sphere of radius 0.2,
centered on the Gaussian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">f_sph</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">dx2</span> <span class="o">&lt;</span> <span class="mf">0.2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1115.3539360527281318</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>           <span class="c1"># adapt the grid</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>  <span class="c1"># estimate the integral</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>The normalization is adjusted to again make the
exact integral equal 1. Integrating as before gives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.992</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">0.992</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.993</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>       <span class="mf">0.992</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">0.97</span>
  <span class="mi">3</span>   <span class="mf">1.002</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">0.996</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.09</span>     <span class="mf">0.91</span>
  <span class="mi">4</span>   <span class="mf">1.004</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>       <span class="mf">0.9973</span><span class="p">(</span><span class="mi">98</span><span class="p">)</span>          <span class="mf">0.10</span>     <span class="mf">0.96</span>
  <span class="mi">5</span>   <span class="mf">1.026</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>       <span class="mf">1.0001</span><span class="p">(</span><span class="mi">93</span><span class="p">)</span>          <span class="mf">0.28</span>     <span class="mf">0.89</span>
  <span class="mi">6</span>   <span class="mf">1.053</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span>       <span class="mf">1.0007</span><span class="p">(</span><span class="mi">93</span><span class="p">)</span>          <span class="mf">0.29</span>     <span class="mf">0.92</span>
  <span class="mi">7</span>   <span class="mf">1.035</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>       <span class="mf">1.0038</span><span class="p">(</span><span class="mi">89</span><span class="p">)</span>          <span class="mf">0.45</span>     <span class="mf">0.85</span>
  <span class="mi">8</span>   <span class="mf">0.991</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>       <span class="mf">1.0014</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>          <span class="mf">0.44</span>     <span class="mf">0.88</span>
  <span class="mi">9</span>   <span class="mf">0.968</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">0.9956</span><span class="p">(</span><span class="mi">73</span><span class="p">)</span>          <span class="mf">0.76</span>     <span class="mf">0.64</span>
 <span class="mi">10</span>   <span class="mf">1.022</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>       <span class="mf">0.9966</span><span class="p">(</span><span class="mi">72</span><span class="p">)</span>          <span class="mf">0.73</span>     <span class="mf">0.68</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">0.9966</span><span class="p">(</span><span class="mi">72</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.68</span>
</pre></div>
</div>
<p>It is a good idea to make the actual integration volume as large a
fraction as possible of the total volume used by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> —
by choosing integration variables properly — so
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> doesn’t spend lots of effort on regions where the integrand
is exactly 0. Also, it can be challenging for <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
to find the region of
non-zero integrand in high dimensions: integrating <code class="docutils literal notranslate"><span class="pre">f_sph(x)</span></code>
in 20 dimensions instead of 4, for example,
would require <code class="docutils literal notranslate"><span class="pre">neval=1e16</span></code>
integrand evaluations per iteration to have any chance of
finding the region of non-zero integrand, because the volume of
the 20-dimensional sphere is a tiny fraction of the total
integration volume. The final error in the example above would have
been cut in half had we used the integration volume
<code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">*</span> <span class="pre">[[0.3,</span> <span class="pre">0.7]]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">[[-1,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1]]</span></code>.</p>
<p>Note, finally, that integration to infinity is also possible:
map the relevant variable into a different variable
of finite range. For example,  an integral over <img class="math" src="_images/math/6736bd811ad81fdfee6a140d5d89a2e1bc375628.svg" alt="x\equiv b z / (1-z)"/>
from 0 to infinity is easily re-expressed as
an integral over <img class="math" src="_images/math/2c56203254af12df1dd4b2c61082bfbed14028f7.svg" alt="z"/> from 0 to 1, where the transformation
emphasizes the region in <img class="math" src="_images/math/ab7f1721dbcf7398485913e30d2b94b3632ff40c.svg" alt="x"/> of order free parameter <img class="math" src="_images/math/5f3942dd8bf9ff56e4aeb2f698c5db1adb475065.svg" alt="b"/>.</p>
<p><strong>Damping:</strong> The result in the previous section
can be improved somewhat by slowing down
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s adaptation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls the speed with which <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
adapts, with smaller <code class="docutils literal notranslate"><span class="pre">alpha</span></code>s giving slower adaptation.
Here we reduce <code class="docutils literal notranslate"><span class="pre">alpha</span></code> to 0.1, from its default value of 0.5, and get
the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">1.008</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>       <span class="mf">1.008</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.993</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>       <span class="mf">0.999</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>           <span class="mf">0.19</span>     <span class="mf">0.66</span>
  <span class="mi">3</span>   <span class="mf">1.005</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>       <span class="mf">1.002</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>           <span class="mf">0.11</span>     <span class="mf">0.89</span>
  <span class="mi">4</span>   <span class="mf">1.016</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">1.006</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.19</span>     <span class="mf">0.91</span>
  <span class="mi">5</span>   <span class="mf">0.973</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">0.9967</span><span class="p">(</span><span class="mi">95</span><span class="p">)</span>          <span class="mf">0.73</span>     <span class="mf">0.57</span>
  <span class="mi">6</span>   <span class="mf">1.016</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">1.0009</span><span class="p">(</span><span class="mi">84</span><span class="p">)</span>          <span class="mf">0.77</span>     <span class="mf">0.57</span>
  <span class="mi">7</span>   <span class="mf">1.008</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">1.0023</span><span class="p">(</span><span class="mi">76</span><span class="p">)</span>          <span class="mf">0.66</span>     <span class="mf">0.68</span>
  <span class="mi">8</span>   <span class="mf">0.990</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">1.0002</span><span class="p">(</span><span class="mi">69</span><span class="p">)</span>          <span class="mf">0.63</span>     <span class="mf">0.73</span>
  <span class="mi">9</span>   <span class="mf">1.008</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">1.0012</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>          <span class="mf">0.58</span>     <span class="mf">0.80</span>
 <span class="mi">10</span>   <span class="mf">0.958</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">0.9959</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>          <span class="mf">1.12</span>     <span class="mf">0.34</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">0.9959</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.34</span>
</pre></div>
</div>
<p>Notice how the errors fluctuate less from iteration to iteration
with the smaller <code class="docutils literal notranslate"><span class="pre">alpha</span></code> in this case.
Persistent, large fluctuations in the size
of the per-iteration errors is often a signal that <code class="docutils literal notranslate"><span class="pre">alpha</span></code> should
be reduced. With larger <code class="docutils literal notranslate"><span class="pre">alpha</span></code>s, <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> can over-react
to random fluctuations it encounters as it samples the integrand.</p>
<p>In general, we want <code class="docutils literal notranslate"><span class="pre">alpha</span></code> to be large enough so that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts
quickly to the integrand, but not so large that it has difficulty
holding on to the optimal tuning once it has found it. The best value
depends upon the integrand.</p>
<p><strong>adapt=False:</strong> Adaptation can be turned off completely
by setting parameter <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code>. There are three reasons one
might do this. The first is if <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is exhibiting the
kind of instability discussed in the previous section — one might
use the following code, instead of that presented there:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f_sph</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The second reason is that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> runs slightly faster when it is
no longer adapting to the integrand. The difference is not signficant
for complicated integrands, but is noticable in simpler cases.</p>
<p>The third reason for turning off adaptation is that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> uses
unweighted averages, rather than weighted averages, to combine
results from different iterations when <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code>.
Unweighted averages are not biased. They have no systematic error
of the sort discussed above, and so give correct results even
for very large numbers of iterations, <code class="docutils literal notranslate"><span class="pre">nitn</span></code>.</p>
<p>The lack of systematic biases is <em>not</em> a strong reason for turning
off adaptation, however, since the biases are
usually negligible (see above). The most important reason is the
first: stability.</p>
<p><code class="docutils literal notranslate"><span class="pre">adapt=False</span></code> is particularly useful when the number of
integrand evaluations <code class="docutils literal notranslate"><span class="pre">neval</span></code> is small for the integrand, leading
to large fluctuations in the errors from iteration to
iteration. For example,
the following output is from an estimate (with <code class="docutils literal notranslate"><span class="pre">neval=2.5e4</span></code>)
of an eight-dimensional
integral with three sharp peaks along the diagonal (Eq.   (45) in
<a class="reference external" href="https://arxiv.org/abs/2009.05112">arXiv_2009.05112</a>, normalized so that the correct answer equals 1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
 <span class="mi">1</span>   <span class="mf">0.75</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span>        <span class="mf">0.75</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span>            <span class="mf">0.00</span>     <span class="mf">1.00</span>
 <span class="mi">2</span>   <span class="mf">0.506</span><span class="p">(</span><span class="mi">58</span><span class="p">)</span>       <span class="mf">0.510</span><span class="p">(</span><span class="mi">58</span><span class="p">)</span>           <span class="mf">0.32</span>     <span class="mf">0.57</span>
 <span class="mi">3</span>   <span class="mf">0.80</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>        <span class="mf">0.530</span><span class="p">(</span><span class="mi">56</span><span class="p">)</span>           <span class="mf">1.02</span>     <span class="mf">0.36</span>
 <span class="mi">4</span>   <span class="mf">0.76</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>        <span class="mf">0.576</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>           <span class="mf">1.81</span>     <span class="mf">0.14</span>
 <span class="mi">5</span>   <span class="mf">1.27</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>        <span class="mf">0.596</span><span class="p">(</span><span class="mi">49</span><span class="p">)</span>           <span class="mf">2.74</span>     <span class="mf">0.03</span>
 <span class="mi">6</span>   <span class="mf">1.10</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>        <span class="mf">0.629</span><span class="p">(</span><span class="mi">48</span><span class="p">)</span>           <span class="mf">3.56</span>     <span class="mf">0.00</span>
 <span class="mi">7</span>   <span class="mf">0.802</span><span class="p">(</span><span class="mi">73</span><span class="p">)</span>       <span class="mf">0.681</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>           <span class="mf">3.63</span>     <span class="mf">0.00</span>
 <span class="mi">8</span>   <span class="mf">2.8</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>        <span class="mf">0.681</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>           <span class="mf">3.27</span>     <span class="mf">0.00</span>
 <span class="mi">9</span>   <span class="mf">0.907</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>       <span class="mf">0.719</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>           <span class="mf">3.52</span>     <span class="mf">0.00</span>
<span class="mi">10</span>   <span class="mf">1.07</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>        <span class="mf">0.736</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>           <span class="mf">3.65</span>     <span class="mf">0.00</span>

<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">average</span>         <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
 <span class="mi">1</span>   <span class="mf">1.13</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>        <span class="mf">1.13</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>            <span class="mf">0.00</span>     <span class="mf">1.00</span>
 <span class="mi">2</span>   <span class="mf">1.064</span><span class="p">(</span><span class="mi">96</span><span class="p">)</span>       <span class="mf">1.095</span><span class="p">(</span><span class="mi">86</span><span class="p">)</span>           <span class="mf">0.13</span>     <span class="mf">0.72</span>
 <span class="mi">3</span>   <span class="mf">1.03</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>        <span class="mf">1.072</span><span class="p">(</span><span class="mi">67</span><span class="p">)</span>           <span class="mf">0.19</span>     <span class="mf">0.83</span>
 <span class="mi">4</span>   <span class="mf">0.924</span><span class="p">(</span><span class="mi">94</span><span class="p">)</span>       <span class="mf">1.035</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>           <span class="mf">0.58</span>     <span class="mf">0.63</span>
 <span class="mi">5</span>   <span class="mf">0.858</span><span class="p">(</span><span class="mi">71</span><span class="p">)</span>       <span class="mf">1.000</span><span class="p">(</span><span class="mi">46</span><span class="p">)</span>           <span class="mf">1.08</span>     <span class="mf">0.37</span>
 <span class="mi">6</span>   <span class="mf">0.97</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>        <span class="mf">0.995</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span>           <span class="mf">0.84</span>     <span class="mf">0.52</span>
 <span class="mi">7</span>   <span class="mf">0.924</span><span class="p">(</span><span class="mi">69</span><span class="p">)</span>       <span class="mf">0.985</span><span class="p">(</span><span class="mi">38</span><span class="p">)</span>           <span class="mf">0.84</span>     <span class="mf">0.54</span>
 <span class="mi">8</span>   <span class="mf">1.19</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>        <span class="mf">1.010</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>           <span class="mf">1.01</span>     <span class="mf">0.42</span>
 <span class="mi">9</span>   <span class="mf">1.74</span><span class="p">(</span><span class="mi">73</span><span class="p">)</span>        <span class="mf">1.092</span><span class="p">(</span><span class="mi">88</span><span class="p">)</span>           <span class="mf">1.01</span>     <span class="mf">0.42</span>
<span class="mi">10</span>   <span class="mf">0.942</span><span class="p">(</span><span class="mi">89</span><span class="p">)</span>       <span class="mf">1.077</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>           <span class="mf">1.02</span>     <span class="mf">0.42</span>
</pre></div>
</div>
<p>The first 10 iterations are used to train the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> map; their
results are discarded. The
next 10 iterations, with <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code>, have uncertainties that
fluctuate in size by an order of magnitude, but still give a reliable
estimate for the integral (1.08(8)). Allowing <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
to continue adapting in the the second set of iterations gives
results like 0.887(25), which is 4.5 standard deviations too low;
the real uncertainty is larger than   ±0.025.</p>
<p>Training the integrator and then setting <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code> for the
final results works best if the number of evaluations per iteration
(<code class="docutils literal notranslate"><span class="pre">neval</span></code>) is the same in both steps. This is because the second
of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s adaptation strategies (<a class="reference internal" href="background.html#adaptive-stratified-sampling"><span class="std std-ref">Adaptive Stratified Sampling</span></a>) is
usually reinitialized when <code class="docutils literal notranslate"><span class="pre">neval</span></code> changes, and so is not
used at all when <code class="docutils literal notranslate"><span class="pre">neval</span></code> is changed at the same time <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code>
is set.</p>
</div></blockquote>
</section>
<section id="multiple-integrands-simultaneously">
<span id="id2"></span><h2>Multiple Integrands Simultaneously<a class="headerlink" href="#multiple-integrands-simultaneously" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> can be used to integrate multiple integrands simultaneously, using
the same integration points for each of the integrands. This is useful
in situations where the integrands have similar structure, with peaks in
the same locations. There can be  signficant advantages in sampling
different integrands at precisely the same points in x space, because
then Monte Carlo estimates for the different integrals are correlated.
If the integrands are very similar to each other, the correlations can be
very strong. This leads to greatly reduced errors in ratios or differences
of the resulting integrals as the fluctuations cancel.</p>
<p>Consider a simple example. We want to compute
the normalization and first two moments of a
sharply peaked probability distribution:</p>
<div class="math">
<p><img src="_images/math/213a324818dbcf826fbb5023f20a16db17e640e4.svg" alt="I_0  &amp;\equiv  \int_0^1 d^4x\;
    \mathrm{e}^{- 200 \sum_{d}(x_d-0.5)^2}\\
I_1  &amp;\equiv \int_0^1 d^4x\; x_0 \;
    \mathrm{e}^{- 200 \sum_{d}(x_d-0.5)^2} \\
I_2 &amp;\equiv \int_0^1 d^4x\; x_0^2 \;
    \mathrm{e}^{- 200 \sum_{d}(x_d-0.5)^2}"/></p>
</div><p>From these integrals we determine the mean and width of the  distribution
projected onto one of the axes:</p>
<div class="math">
<p><img src="_images/math/8a2f87c47c9a6ee77d7e8f816eada511053bee65.svg" alt="\langle x \rangle  &amp;\equiv I_1 / I_0 \\[1ex]
\sigma_x^2  &amp;\equiv \langle x^2 \rangle - \langle x \rangle^2 \\
           &amp;= I_2 / I_0  - (I_1 / I_0)^2"/></p>
</div><p>This can be done using the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="c1"># adapt grid</span>
<span class="n">training</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

<span class="c1"># final analysis</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I[0] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;  I[1] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;  I[2] =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q = </span><span class="si">%.2f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;x&gt; =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="s1">&#39;sigma_x**2 = &lt;x**2&gt; - &lt;x&gt;**2 =&#39;</span><span class="p">,</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">correlation matrix:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
<p>The code is very similar to that used in the previous section. The
main difference is that the integrand function and <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
return arrays of results — in
both cases, one result for each of the three integrals. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> always adapts to
the first integrand in the array. The <code class="docutils literal notranslate"><span class="pre">Q</span></code> value is for all three
of the integrals, taken together.</p>
<p>The code produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00024682</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>   <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.000123417</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>   <span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.000062327</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mf">0.93</span>

<span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mf">0.500017</span><span class="p">(</span><span class="mi">49</span><span class="p">)</span>
<span class="n">sigma_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;**</span><span class="mi">2</span> <span class="o">=</span> <span class="mf">0.0024983</span><span class="p">(</span><span class="mi">73</span><span class="p">)</span>

<span class="n">correlation</span> <span class="n">matrix</span><span class="p">:</span>
 <span class="p">[[</span><span class="mf">1.</span>         <span class="mf">0.98002885</span> <span class="mf">0.92558296</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.98002885</span> <span class="mf">1.</span>         <span class="mf">0.98157932</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">0.92558296</span> <span class="mf">0.98157932</span> <span class="mf">1.</span>        <span class="p">]]</span>
</pre></div>
</div>
<p>The estimates for the individual integrals are separately accurate to
about ±0.05%,
but the estimate for <img class="math" src="_images/math/f9f9752ccd7f184cdb486e2ca6c03ff1ef69bc0b.svg" alt="\langle x \rangle = I_1/I_0"/>
is accurate to ±0.01%.
This is almost an order
of magnitude (8x) more accurate than we would obtain absent correlations.
The correlation matrix shows that there is 98% correlation between the
statistical fluctuations in estimates for <img class="math" src="_images/math/fa353b8267fd50c5aabbc0ad8314d3207d81f102.svg" alt="I_0"/> and <img class="math" src="_images/math/cdb04439720001c8df035b65f5c33b6fccab9e06.svg" alt="I_1"/>,
and so the bulk of these fluctuations cancel in the ratio.
The estimate for the variance <img class="math" src="_images/math/576f10392256aaa6c7913c21937740c670bdac43.svg" alt="\sigma^2_x"/>
is 48x more accurate than we would
have obtained had the integrals been evaluated separately. Both estimates
are correct to within the quoted errors.</p>
<p>The individual results are objects of type <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>, which
represent Gaussian random variables. Such objects have means
(<code class="docutils literal notranslate"><span class="pre">result[i].mean</span></code>) and standard deviations (<code class="docutils literal notranslate"><span class="pre">result[i].sdev</span></code>), but
also can be statistically correlated with other <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
Such correlations are handled automatically by <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code> when
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s are combined with each other or with numbers in
arithmetical expressions. (Documentation for <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code> can be found
at <a class="reference external" href="https://gvar.readthedocs.io">https://gvar.readthedocs.io</a> or with the source code
at <a class="reference external" href="https://github.com/gplepage/gvar.git">https://github.com/gplepage/gvar.git</a>.)</p>
</section>
<section id="dictionaries">
<h2>Dictionaries<a class="headerlink" href="#dictionaries" title="Link to this heading">¶</a></h2>
<p>Integrands can return dictionaries instead of arrays. The example
in the previous section,
for example, can be rewritten as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;x**2&#39;</span><span class="p">:</span><span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">}</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="c1"># adapt grid</span>
<span class="n">training</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

<span class="c1"># final analysis</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q = </span><span class="si">%.2f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;x&gt; =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="s1">&#39;sigma_x**2 = &lt;x**2&gt; - &lt;x&gt;**2 =&#39;</span><span class="p">,</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;x**2&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>which returns the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mf">0.00024682</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mf">0.000123417</span><span class="p">(</span><span class="mi">61</span><span class="p">),</span><span class="s1">&#39;x**2&#39;</span><span class="p">:</span> <span class="mf">0.000062327</span><span class="p">(</span><span class="mi">33</span><span class="p">)}</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mf">0.93</span>

<span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mf">0.500017</span><span class="p">(</span><span class="mi">49</span><span class="p">)</span>
<span class="n">sigma_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">&gt;</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;**</span><span class="mi">2</span> <span class="o">=</span> <span class="mf">0.0024983</span><span class="p">(</span><span class="mi">73</span><span class="p">)</span>
</pre></div>
</div>
<p>The result returned by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is a dictionary using the same keys as the
dictionary returned by the integrand. Using a dictionary with descriptive
keys, instead of an array, can often make code more intelligible, and,
therefore, easier to write  and maintain. Here the values in the integrand’s
dictionary are all numbers; in general, values can be  either numbers or
arrays (of any shape).</p>
<p>Dictionaries can also be used for the integration variables.
For example, the following code calculates the volume of a
unit sphere using spherical coordinates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">xd</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">theta</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">phi</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
<span class="n">volume</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
</pre></div>
</div>
<p>Running this code gives a result of 4.1852(44) which agrees well (0.1%) with the correct
result <img class="math" src="_images/math/3492d77fb5139b407b90cbbe088959538244a99c.svg" alt="4\pi/3"/>. This can be generalized to <code class="docutils literal notranslate"><span class="pre">DIM</span></code> dimensions,
where now <code class="docutils literal notranslate"><span class="pre">xd['phi']</span></code> is an array of variables: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>

<span class="n">DIM</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">xd</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span>
    <span class="c1"># construct Euclidean coordinates, Jacobian</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">DIM</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span>
    <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="c1"># calculate contribution to sphere&#39;s volume</span>
    <span class="k">return</span> <span class="n">jac</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
    <span class="n">r</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">phi</span><span class="o">=</span><span class="p">(</span><span class="n">DIM</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span>
    <span class="p">))</span>
<span class="n">warmup</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">volume</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">settings</span><span class="p">(),</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;volume(dim=</span><span class="si">{</span><span class="n">DIM</span><span class="si">}</span><span class="s1">) = </span><span class="si">{</span><span class="n">volume</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This code generates the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Integrator</span> <span class="n">Settings</span><span class="p">:</span>
    <span class="mi">1000</span> <span class="p">(</span><span class="n">approx</span><span class="p">)</span> <span class="n">integrand</span> <span class="n">evaluations</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">of</span> <span class="mi">10</span> <span class="n">iterations</span>
    <span class="n">number</span> <span class="n">of</span><span class="p">:</span> <span class="n">strata</span><span class="o">/</span><span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]</span>
               <span class="n">increments</span><span class="o">/</span><span class="n">axis</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">99</span>  <span class="mi">99</span>  <span class="mi">99</span> <span class="mi">100</span> <span class="mi">100</span><span class="p">]</span>
               <span class="n">h</span><span class="o">-</span><span class="n">cubes</span> <span class="o">=</span> <span class="mi">108</span>  <span class="n">processors</span> <span class="o">=</span> <span class="mi">1</span>
               <span class="n">evaluations</span><span class="o">/</span><span class="n">batch</span> <span class="o">&gt;=</span> <span class="mf">5e+04</span>
               <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">evaluations</span><span class="o">/</span><span class="n">h</span><span class="o">-</span><span class="n">cube</span> <span class="o">&lt;=</span> <span class="mf">5e+04</span>
    <span class="n">minimize_mem</span> <span class="o">=</span> <span class="kc">False</span>  <span class="n">adapt_to_errors</span> <span class="o">=</span> <span class="kc">False</span>  <span class="n">adapt</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">accuracy</span><span class="p">:</span> <span class="n">relative</span> <span class="o">=</span> <span class="mi">0</span>  <span class="n">absolute</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">damping</span><span class="p">:</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="n">beta</span><span class="o">=</span> <span class="mf">0.75</span>

    <span class="n">key</span><span class="o">/</span><span class="n">index</span>    <span class="n">axis</span>          <span class="n">integration</span> <span class="n">limits</span>
    <span class="o">---------------------------------------------</span>
            <span class="n">r</span>       <span class="mi">0</span>                  <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">phi</span> <span class="mi">0</span>       <span class="mi">1</span>    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.141592653589793</span><span class="p">)</span>
            <span class="mi">1</span>       <span class="mi">2</span>    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.141592653589793</span><span class="p">)</span>
            <span class="mi">2</span>       <span class="mi">3</span>    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.141592653589793</span><span class="p">)</span>
            <span class="mi">3</span>       <span class="mi">4</span>    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">6.283185307179586</span><span class="p">)</span>
 

<span class="n">volume</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.254</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="calculating-distributions">
<h2>Calculating Distributions<a class="headerlink" href="#calculating-distributions" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is often used to calculate distributions. The following
code, for example, evaluates both an integral <code class="docutils literal notranslate"><span class="pre">I</span></code> and the contributions
<code class="docutils literal notranslate"><span class="pre">dI</span></code> to the integral coming from each of five different intervals <code class="docutils literal notranslate"><span class="pre">dr</span></code>
in the radius measured
from the center of the integration volume. The normalized contributions
<code class="docutils literal notranslate"><span class="pre">dI/I</span></code> are then tabulated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">RMAX</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

<span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span><span class="p">)</span>
    <span class="c1"># add I to appropriate bin in dI</span>
    <span class="n">dI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">RMAX</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dI</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dx2</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">dr</span><span class="p">)</span>
    <span class="n">dI</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">dI</span><span class="o">=</span><span class="n">dI</span><span class="p">)</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>

<span class="c1"># results returned in a dictionary</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   I =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dI/I =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;dI&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sum(dI/I) =&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;dI&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Note the check at the end, to verify that the sum of the
<code class="docutils literal notranslate"><span class="pre">dI[i]</span></code>s equals the original integral. Running this script gives
the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.85040</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>     <span class="mf">0.85040</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>         <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.85039</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>     <span class="mf">0.85040</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>         <span class="mf">0.76</span>     <span class="mf">0.60</span>
  <span class="mi">3</span>   <span class="mf">0.85085</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>     <span class="mf">0.85061</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>         <span class="mf">0.63</span>     <span class="mf">0.82</span>
  <span class="mi">4</span>   <span class="mf">0.85105</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>     <span class="mf">0.85079</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>         <span class="mf">0.52</span>     <span class="mf">0.95</span>
  <span class="mi">5</span>   <span class="mf">0.85105</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>     <span class="mf">0.85087</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>         <span class="mf">0.60</span>     <span class="mf">0.94</span>
  <span class="mi">6</span>   <span class="mf">0.85097</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>     <span class="mf">0.85091</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>         <span class="mf">0.55</span>     <span class="mf">0.98</span>
  <span class="mi">7</span>   <span class="mf">0.85099</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>     <span class="mf">0.85096</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>         <span class="mf">0.72</span>     <span class="mf">0.90</span>
  <span class="mi">8</span>   <span class="mf">0.85112</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>     <span class="mf">0.851013</span><span class="p">(</span><span class="mi">93</span><span class="p">)</span>        <span class="mf">0.66</span>     <span class="mf">0.95</span>
  <span class="mi">9</span>   <span class="mf">0.85114</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>     <span class="mf">0.851053</span><span class="p">(</span><span class="mi">79</span><span class="p">)</span>        <span class="mf">0.70</span>     <span class="mf">0.94</span>
 <span class="mi">10</span>   <span class="mf">0.85101</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>     <span class="mf">0.851041</span><span class="p">(</span><span class="mi">67</span><span class="p">)</span>        <span class="mf">0.68</span>     <span class="mf">0.96</span>

   <span class="n">I</span> <span class="o">=</span> <span class="mf">0.851041</span><span class="p">(</span><span class="mi">67</span><span class="p">)</span>
<span class="n">dI</span><span class="o">/</span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0759</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="mf">0.2091</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span> <span class="mf">0.3217</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span> <span class="mf">0.3209</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span> <span class="mf">0.0723</span><span class="p">(</span><span class="mi">12</span><span class="p">)]</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">dI</span><span class="o">/</span><span class="n">I</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.999999999996</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>
</pre></div>
</div>
<p>The integrator adapts to the full integral <code class="docutils literal notranslate"><span class="pre">I</span></code> but also gives
accurate results for the distribution <code class="docutils literal notranslate"><span class="pre">dI</span></code> (though not quite as
accurate). Note that <code class="docutils literal notranslate"><span class="pre">sum(dI/I)</span></code> is much more accurate than
any individual <code class="docutils literal notranslate"><span class="pre">dI/I</span></code>, because of correlations between
the different <code class="docutils literal notranslate"><span class="pre">dI/I</span></code> values. (The uncertainty on <code class="docutils literal notranslate"><span class="pre">sum(dI/I)</span></code> would
be exactly zero absent roundoff errors.)</p>
<p>Often one has more than five bins in a distribution. Increasing the
number to 100 in the example above reveals a problem:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.85040</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>     <span class="mf">0.85040</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>         <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.85039</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>     <span class="mf">0.85079</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>         <span class="mf">0.75</span>     <span class="mf">0.97</span>
  <span class="mi">3</span>   <span class="mf">0.85085</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>     <span class="mf">0.820</span><span class="p">(</span><span class="mi">49</span><span class="p">)</span>           <span class="mf">0.73</span>     <span class="mf">1.00</span>
  <span class="mi">4</span>   <span class="mf">0.85105</span><span class="p">(</span><span class="mi">33</span><span class="p">)</span>     <span class="mf">0.813</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>           <span class="mf">0.81</span>     <span class="mf">0.99</span>
  <span class="mi">5</span>   <span class="mf">0.85105</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>     <span class="mf">0.837</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>           <span class="mf">0.96</span>     <span class="mf">0.73</span>
  <span class="mi">6</span>   <span class="mf">0.85097</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>     <span class="mf">0.85236</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>         <span class="mf">1.10</span>     <span class="mf">0.06</span>
  <span class="mi">7</span>   <span class="mf">0.85099</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>     <span class="mf">0.85242</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>         <span class="mf">1.19</span>     <span class="mf">0.00</span>
  <span class="mi">8</span>   <span class="mf">0.85112</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>     <span class="mf">0.85242</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>         <span class="mf">1.22</span>     <span class="mf">0.00</span>
  <span class="mi">9</span>   <span class="mf">0.85114</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>     <span class="mf">0.85234</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>         <span class="mf">1.22</span>     <span class="mf">0.00</span>
 <span class="mi">10</span>   <span class="mf">0.85101</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>     <span class="mf">0.85179</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>         <span class="mf">1.25</span>     <span class="mf">0.00</span>

   <span class="n">I</span> <span class="o">=</span> <span class="mf">0.85179</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="n">dI</span><span class="o">/</span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.00012</span><span class="p">(</span><span class="mi">87</span><span class="p">)</span> <span class="mf">0.00177</span><span class="p">(</span><span class="mi">62</span><span class="p">)</span> <span class="mf">0.00016</span><span class="p">(</span><span class="mi">83</span><span class="p">)</span> <span class="mf">0.00067</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span> <span class="mf">0.00103</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span><span class="o">...</span><span class="p">]</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">dI</span><span class="o">/</span><span class="n">I</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0000117</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>
</pre></div>
</div>
<p>Something is going wrong with the weighted averages of the results
from different iterations, as is clear by the third iteration. The
weights used in the weighted average are obtained from the inverse
of the covariance matrix for the different components of the
integral — here a 101×101 matrix. This matrix becomes quite
singular as it grows, and therefore is quite sensitive to even small
errors in the
covariance matrix. These errors, particularly in early iterations,
can introduce large errors in the weighted averages.</p>
<p>This problem can be addressed by increasing the number of integrand
evaluations per iteration <code class="docutils literal notranslate"><span class="pre">neval</span></code>, which increases the accuracy
of the Monte Carlo estimate of the covariance matrix. A more efficient
solution in this case, however, is to break the integration into two parts: one
where the integrator is adapted to the integrand, but the results
are discarded; and a second step where adaptation is turned off
with <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code> to  obtain the final result. As discussed above,
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> does not use a weighted average when <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code> and
so the inversion of the covariance matrices is unnecessary.</p>
<p>To implement this strategy in the code above, replace the line</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>
</pre></div>
</div>
<p>with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">discard</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>                <span class="c1"># adapt to grid</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>    <span class="c1"># no further adaptation</span>
</pre></div>
</div>
<p>This gives the following output:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">average</span>         <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.85113</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.85113</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>         <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.85113</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>     <span class="mf">0.851130</span><span class="p">(</span><span class="mi">81</span><span class="p">)</span>        <span class="mf">0.99</span>     <span class="mf">0.50</span>
  <span class="mi">3</span>   <span class="mf">0.85124</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.851166</span><span class="p">(</span><span class="mi">65</span><span class="p">)</span>        <span class="mf">1.08</span>     <span class="mf">0.21</span>
  <span class="mi">4</span>   <span class="mf">0.85129</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.851197</span><span class="p">(</span><span class="mi">56</span><span class="p">)</span>        <span class="mf">1.04</span>     <span class="mf">0.31</span>
  <span class="mi">5</span>   <span class="mf">0.85105</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>     <span class="mf">0.851168</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>        <span class="mf">0.99</span>     <span class="mf">0.54</span>
  <span class="mi">6</span>   <span class="mf">0.85120</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.851173</span><span class="p">(</span><span class="mi">46</span><span class="p">)</span>        <span class="mf">0.99</span>     <span class="mf">0.57</span>
  <span class="mi">7</span>   <span class="mf">0.85114</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.851169</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span>        <span class="mf">0.98</span>     <span class="mf">0.63</span>
  <span class="mi">8</span>   <span class="mf">0.85107</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.851156</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>        <span class="mf">1.03</span>     <span class="mf">0.29</span>
  <span class="mi">9</span>   <span class="mf">0.85114</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.851154</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>        <span class="mf">1.04</span>     <span class="mf">0.19</span>
 <span class="mi">10</span>   <span class="mf">0.85110</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="mf">0.851149</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>        <span class="mf">1.02</span>     <span class="mf">0.31</span>

   <span class="n">I</span> <span class="o">=</span> <span class="mf">0.851149</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>
<span class="n">dI</span><span class="o">/</span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.00034</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="mf">0.00067</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span> <span class="mf">0.00067</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span> <span class="mf">0.00185</span><span class="p">(</span><span class="mi">49</span><span class="p">)</span> <span class="mf">0.00101</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span><span class="o">...</span><span class="p">]</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">dI</span><span class="o">/</span><span class="n">I</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.000000000000</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The correct result for <code class="docutils literal notranslate"><span class="pre">I</span></code> is   0.85112.</p>
</section>
<section id="pdf-integrals">
<h2>PDF Integrals<a class="headerlink" href="#pdf-integrals" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> module has a special-purpose integrator for
evaluating averages over probability distributions.
In its simplest form,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g_ev</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">PDFIntegrator</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p>creates an integrator optimized for the multi-dimensional Gaussian
probability distribution corresponding to <code class="docutils literal notranslate"><span class="pre">g</span></code>. (<code class="docutils literal notranslate"><span class="pre">g</span></code> is
an array of Gaussian random variables of type <code class="docutils literal notranslate"><span class="pre">gvar.GVar</span></code>,
or a dictionary whose
values are <code class="docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.)
Then <code class="docutils literal notranslate"><span class="pre">g_ev(f)</span></code> evaluates the expectation value of a
function <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> with respect to this distribution,
where <code class="docutils literal notranslate"><span class="pre">p</span></code> is a point in the distribution’s parameter
space.</p>
<p>More generally</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pdf_ev</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">PDFIntegrator</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">pdf</span><span class="o">=</span><span class="n">pdf</span><span class="p">)</span>
</pre></div>
</div>
<p>creates an integrator which calculates expectation values with
respect to an arbitrary probability density function <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code>.
The parameter space for points <code class="docutils literal notranslate"><span class="pre">p</span></code> is again defined by
and optimized for the PDF corresponding to <code class="docutils literal notranslate"><span class="pre">g</span></code>, but
expectation values are calculated with <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code>. Typically
<code class="docutils literal notranslate"><span class="pre">g</span></code>’s means and covariance would be chosen to emphasize
the regions where <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> is large (e.g., <code class="docutils literal notranslate"><span class="pre">g</span></code> might be
set equal to the prior in a Bayesian analysis).</p>
<p>In general, the integrator uses <code class="docutils literal notranslate"><span class="pre">param</span></code> to define and optimize the
internal integration parameters. It re-expresses integrals in
terms of variables
that diagonalize <code class="docutils literal notranslate"><span class="pre">param</span></code>’s correlation matrix and are centered at
its mean value. This greatly facilitates integration over these
variables using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>, making integrals over
many parameters feasible, even when the parameters are highly
correlated. <a class="reference internal" href="vegas.html#vegas.PDFIntegrator" title="vegas.PDFIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFIntegrator</span></code></a> also pre-adapts the integrator
to <code class="docutils literal notranslate"><span class="pre">param</span></code>’s PDF so it is often unnecessary to discard early iterations.</p>
<p><a class="reference internal" href="vegas.html#vegas.PDFIntegrator" title="vegas.PDFIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFIntegrator</span></code></a> evaluates the
integrals of both <code class="docutils literal notranslate"><span class="pre">pdf(p)</span> <span class="pre">*</span> <span class="pre">f(p)</span></code> and <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code>. The expectation
value is the ratio of the two integrals, so the PDF need not be
normalized. Note also that Monte Carlo uncertainties in
the two integrals are often highly correlated, in which case
the uncertainties are significantly reduced in the ratio.</p>
<p>A simple illustration of <a class="reference internal" href="vegas.html#vegas.PDFIntegrator" title="vegas.PDFIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFIntegrator</span></code></a> is given by the following
code, where <code class="docutils literal notranslate"><span class="pre">g</span></code> determines both the parameterization of the integrals
and the PDF used for expectation values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="c1"># multi-dimensional distribution</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
<span class="n">g</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="n">g</span><span class="p">[</span><span class="s1">&#39;fb(b)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="s1">&#39;fb&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>

<span class="c1"># integrator for expectation values in distribution g</span>
<span class="n">g_ev</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">PDFIntegrator</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

<span class="c1"># adapt integrator to the PDF</span>
<span class="n">g_ev</span><span class="p">(</span><span class="n">neval</span><span class="o">=</span><span class="mi">10_000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># want expectation value of [fp, fp**2]</span>
<span class="k">def</span> <span class="nf">f_f2</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">b</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>

<span class="c1"># &lt;f_f2&gt; in distribution g</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">g_ev</span><span class="p">(</span><span class="n">f_f2</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;results =&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># mean and standard deviation of fp&#39;s distribution</span>
<span class="n">fmean</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">fsdev</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;fp.mean =&#39;</span><span class="p">,</span> <span class="n">fmean</span><span class="p">,</span> <span class="s1">&#39;   fp.sdev =&#39;</span><span class="p">,</span> <span class="n">fsdev</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Gaussian approx&#39;n for fp =&quot;</span><span class="p">,</span> <span class="n">f_f2</span><span class="p">(</span><span class="n">g</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># g&#39;s pdf norm</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PDF norm =&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">pdfnorm</span><span class="p">)</span>
</pre></div>
</div>
<p>Here the distribution <code class="docutils literal notranslate"><span class="pre">g</span></code> describes two highly correlated Gaussian
variables, <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">a[1]</span></code>, and a third uncorrelated variable <code class="docutils literal notranslate"><span class="pre">b</span></code>
that is uniformly distributed on the interval [0,2] (see the <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code>
documentation for more information).
We use the integrator to calculated  the expectation value of
<code class="docutils literal notranslate"><span class="pre">fp</span> <span class="pre">=</span> <span class="pre">a[0]*a[1]</span> <span class="pre">+</span> <span class="pre">3*b</span></code> and <code class="docutils literal notranslate"><span class="pre">fp**2</span></code>, so we can compute the
mean and standard
deviation of the <code class="docutils literal notranslate"><span class="pre">fp</span></code>   distribution. The output from this code
shows that the Gaussian approximation 5.0(3.8) for the mean and
standard deviation is not particularly
close to the correct value   6.0(3.8):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">average</span>         <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.9995</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>      <span class="mf">0.9995</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>          <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.0011</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>      <span class="mf">1.00030</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>         <span class="mf">0.36</span>     <span class="mf">0.78</span>
  <span class="mi">3</span>   <span class="mf">1.0013</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>      <span class="mf">1.00062</span><span class="p">(</span><span class="mi">65</span><span class="p">)</span>         <span class="mf">0.31</span>     <span class="mf">0.93</span>
  <span class="mi">4</span>   <span class="mf">1.0003</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>      <span class="mf">1.00055</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>         <span class="mf">0.24</span>     <span class="mf">0.99</span>
  <span class="mi">5</span>   <span class="mf">1.0000</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>      <span class="mf">1.00044</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>         <span class="mf">0.45</span>     <span class="mf">0.94</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.9996</span><span class="p">(</span><span class="mi">54</span><span class="p">)</span> <span class="mf">50.09</span><span class="p">(</span><span class="mi">15</span><span class="p">)]</span> 

<span class="n">fp</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="mf">5.9996</span><span class="p">(</span><span class="mi">54</span><span class="p">)</span>    <span class="n">fp</span><span class="o">.</span><span class="n">sdev</span> <span class="o">=</span> <span class="mf">3.755</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="n">Gaussian</span> <span class="n">approx</span><span class="s1">&#39;n for fp = 5.0(3.8) </span>

<span class="n">PDF</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">1.00044</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>In general the function <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> in <code class="docutils literal notranslate"><span class="pre">g_ev(f)</span></code> can return a number,
or an array of
numbers, or a dictionary whose values are numbers or arrays of numbers.
This allows multiple expectation values to be evaluated simultaneously.</p>
<p>The example above can be coded much more simply using the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">PDFIntegrator.stats()</span></code> method to evaluate the
expectation value of function <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> (rather
than <code class="docutils literal notranslate"><span class="pre">f_f2(p)</span></code> above):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># want expectation value of f(p)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">b</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">g_ev</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;results =&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;   f(g) =&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">correlation matrix:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">evalcorr</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]]))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">stats(f)</span></code> calculates both the mean values and the standard deviations of
each component of <code class="docutils literal notranslate"><span class="pre">f(p)</span></code>, combining them into <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code> objects.
(The standard deviations include the uncertainties coming from the integration
added in quadrature with the uncertainties coming from the distribution.)
The output from this code compares the actual means and standard deviations
from <code class="docutils literal notranslate"><span class="pre">g_ev.stats(f)</span></code> with what is obtained from the Gaussian
approximation (<code class="docutils literal notranslate"><span class="pre">f(g)</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.00</span><span class="p">(</span><span class="mi">58</span><span class="p">),</span> <span class="s1">&#39;fp&#39;</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">(</span><span class="mf">3.7</span><span class="p">)}</span>
   <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">),</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.00</span><span class="p">(</span><span class="mi">80</span><span class="p">),</span> <span class="s1">&#39;fp&#39;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">(</span><span class="mf">3.8</span><span class="p">)}</span>

<span class="n">correlation</span> <span class="n">matrix</span><span class="p">:</span>
<span class="p">[[</span> <span class="mf">1.00000000e+00</span>  <span class="mf">9.90034523e-01</span> <span class="o">-</span><span class="mf">3.17798188e-04</span>  <span class="mf">7.96573054e-01</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">9.90034523e-01</span>  <span class="mf">1.00000000e+00</span> <span class="o">-</span><span class="mf">6.21970730e-04</span>  <span class="mf">7.99212165e-01</span><span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">3.17798188e-04</span> <span class="o">-</span><span class="mf">6.21970730e-04</span>  <span class="mf">1.00000000e+00</span>  <span class="mf">4.63514253e-01</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">7.96573054e-01</span>  <span class="mf">7.99212165e-01</span>  <span class="mf">4.63514253e-01</span>  <span class="mf">1.00000000e+00</span><span class="p">]]</span>
</pre></div>
</div>
<p>This shows that the results for <code class="docutils literal notranslate"><span class="pre">f['a']</span></code> agree with the inputs (as expected because
they are Gaussian), but this is less true for <code class="docutils literal notranslate"><span class="pre">r['b']</span></code> and <code class="docutils literal notranslate"><span class="pre">r['fp']</span></code> whose
distributions are less well approximated by a Gaussian.</p>
<p>Additional information can be obtained by setting the keyword arguments <code class="docutils literal notranslate"><span class="pre">moments</span></code>
and/or <code class="docutils literal notranslate"><span class="pre">histograms</span></code> equal to <code class="docutils literal notranslate"><span class="pre">True</span></code> in <code class="xref py py-meth docutils literal notranslate"><span class="pre">PDFIntegrator.stats()</span></code>. The code</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">g_ev</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">histograms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Statistics for fp:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span>
<span class="n">plt</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot_histogram</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;a[0] * a[1] + 3 * b&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>shows the statistical analysis for <code class="docutils literal notranslate"><span class="pre">fp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Statistics</span> <span class="k">for</span> <span class="n">fp</span><span class="p">:</span>
   <span class="n">mean</span> <span class="o">=</span> <span class="mf">5.9941</span><span class="p">(</span><span class="mi">57</span><span class="p">)</span>   <span class="n">sdev</span> <span class="o">=</span> <span class="mf">3.732</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>   <span class="n">skew</span> <span class="o">=</span> <span class="mf">1.166</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>   <span class="n">ex_kurt</span> <span class="o">=</span> <span class="mf">2.264</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
   <span class="n">split</span><span class="o">-</span><span class="n">normal</span><span class="p">:</span> <span class="mf">3.4084</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="o">+/-</span> <span class="mf">4.765</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="o">/</span><span class="mf">1.7320</span><span class="p">(</span><span class="mi">57</span><span class="p">)</span>
         <span class="n">median</span><span class="p">:</span> <span class="mf">5.3598</span><span class="p">(</span><span class="mi">57</span><span class="p">)</span> <span class="o">+/-</span> <span class="mf">4.048</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mf">2.8818</span><span class="p">(</span><span class="mi">88</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">g_ev.stats(f,</span> <span class="pre">moments=True,</span> <span class="pre">histograms=True)</span></code> calculates
moments for each output quantity, and uses the moments to determines
the mean, standard deviation, skewness, and excess kurtosis of each distribution. It also
calculates a histogram for each distribution and fits the histogram with two
two-sided Gaussian models: one that is continuous (split-normal), and the other
that is discontinuous centered on the median. The uncertainties shown for
each quantity come from the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> integrations.</p>
<p>The last line in
the code above displays the histogram
for <code class="docutils literal notranslate"><span class="pre">fp</span></code>, which confirms that it is not quite Gaussian:</p>
<a class="reference internal image-reference" href="_images/eg7b-plt.png"><img alt="_images/eg7b-plt.png" src="_images/eg7b-plt.png" style="width: 70%;" /></a>
<p>The discussion in <a class="reference internal" href="outliers.html#case-curve-fitting"><span class="std std-ref">Case Study: Bayesian Curve Fitting</span></a> illustrates how
<a class="reference internal" href="vegas.html#vegas.PDFIntegrator" title="vegas.PDFIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFIntegrator</span></code></a> can be used with a non-Gaussian PDF in two
examples, one with 4   parameters
and the other with 22   parameters. It also shows how to
use <a class="reference internal" href="vegas.html#vegas.PDFIntegrator.sample" title="vegas.PDFIntegrator.sample"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vegas.PDFIntegrator.sample()</span></code></a> to create (weighted)
random samples of parameter points whose density is proportional
to the integrator’s PDF.</p>
<p>Finally, note that the <code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code>
Python module uses <a class="reference internal" href="vegas.html#vegas.PDFIntegrator" title="vegas.PDFIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFIntegrator</span></code></a> to implement a least-squares
fitter <code class="xref py py-class docutils literal notranslate"><span class="pre">vegas_fit</span></code>
that uses Bayesian integration (rather than minimization).</p>
</section>
<section id="faster-integrands">
<span id="id3"></span><h2>Faster Integrands<a class="headerlink" href="#faster-integrands" title="Link to this heading">¶</a></h2>
<p>The computational cost of a realistic multidimensional integral
comes mostly from
the cost of evaluating the integrand at the Monte Carlo sample
points. Integrands written in pure Python are probably fast
enough for problems where <code class="docutils literal notranslate"><span class="pre">neval=1e3</span></code> or <code class="docutils literal notranslate"><span class="pre">neval=1e4</span></code> gives
enough precision. Some problems, however, require
hundreds of thousands or millions of function evaluations, or more.</p>
<p>We can significantly reduce the cost of evaluating the integrand
by using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s batch mode and <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> vectors. For example,
the following code runs in about 58 min (on a 2024 laptop):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">ridge</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s2">&quot; Ridge of N Gaussians distributed along part of the diagonal. &quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x0</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">norm</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">warmup</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">   Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>It generates the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="mf">0.99987</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.81</span>
</pre></div>
</div>
<p>Adding a decorator to the integrand function <code class="docutils literal notranslate"><span class="pre">ridge(x)</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@vegas</span><span class="o">.</span><span class="n">rbatchintegrand</span>
<span class="k">def</span> <span class="nf">ridge</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>reduces the run time to 20 sec, which is more than 170 times faster.</p>
<p>The decorator instructs <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to present integration points to
the integrand in batches of approximately 50,000 points
(<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> parameter <code class="docutils literal notranslate"><span class="pre">min_neval_batch</span></code>)
rather than offering them one at a time.
Here, for example, function <code class="docutils literal notranslate"><span class="pre">ridge(x)</span></code> with the decorator
takes as its argument  an array of integration
points — <code class="docutils literal notranslate"><span class="pre">x[d,</span> <span class="pre">i]</span></code> where <code class="docutils literal notranslate"><span class="pre">d=0...</span></code> labels the direction and
<code class="docutils literal notranslate"><span class="pre">i=0...</span></code> the integration point — and returns an array of integrand
values <code class="docutils literal notranslate"><span class="pre">ans[i]</span> <span class="pre">*</span> <span class="pre">norm</span></code> corresponding  to those points. As a result
the code uses <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> vectorization to evaluate the integrand
for all 50,000 integration points in the batch at the same time, which is
much faster than handling the points separately.
The loop in the integrand could have been rewritten</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x0</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="n">dx2</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">ans</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">[:])</span>
</pre></div>
</div>
<p>to make the batch index explicit (<code class="docutils literal notranslate"><span class="pre">:</span></code>); here <code class="docutils literal notranslate"><span class="pre">x[d]</span></code>,
<code class="docutils literal notranslate"><span class="pre">dx2</span></code>, and <code class="docutils literal notranslate"><span class="pre">ans</span></code> are all <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> arrays with
50,000 values, one for each integration point. Typically
one must modify the integrand
code to deal with the extra index <code class="docutils literal notranslate"><span class="pre">i</span></code>
when adding a batch decorator, but that wasn’t
necessary in <code class="docutils literal notranslate"><span class="pre">ridge</span></code> because trailing indices can be
left implicit in <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> arrays.</p>
<p>The advantage gained from using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s batch mode
(with <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> vectorization)
is particularly
large in this example because the integrand is quite expensive to evaluate.
The original (non-batch) integral runs 160 times faster when <code class="docutils literal notranslate"><span class="pre">N</span></code> is
decreased from <code class="docutils literal notranslate"><span class="pre">N=1000</span></code> to <code class="docutils literal notranslate"><span class="pre">N=1</span></code>. Batch mode is
still faster then, but by a more modest factor of about 50.</p>
<p>An alternative to a function decorated with <a class="reference internal" href="vegas.html#vegas.rbatchintegrand" title="vegas.rbatchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.rbatchintegrand()</span></code></a> is
a class, derived from <a class="reference internal" href="vegas.html#vegas.RBatchIntegrand" title="vegas.RBatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RBatchIntegrand</span></code></a>, that behaves
like a batch integrand:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">batch_ridge</span><span class="p">(</span><span class="n">vegas</span><span class="o">.</span><span class="n">RBatchIntegrand</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot; Ridge of N Gaussians distributed along part of the diagonal. &quot;</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0array</span><span class="p">:</span>
            <span class="n">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>

<span class="n">ridge</span> <span class="o">=</span> <span class="n">batch_ridge</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">ridge</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">warmup</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">   Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>This version is as fast as the previous batch integrand, but is
potentially more flexible because it is built around a class rather
than a function.</p>
<p>Batch mode is also useful for array-valued and dictionary-valued integrands.
For example, the following two integrands
(see <a class="reference internal" href="#multiple-integrands-simultaneously"><span class="std std-ref">Multiple Integrands Simultaneously</span></a>)
are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">rbatchintegrand</span>
<span class="k">def</span> <span class="nf">f_rbatch</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>But the second integrand is much faster because again <code class="docutils literal notranslate"><span class="pre">dx2</span></code>, <code class="docutils literal notranslate"><span class="pre">x[d]</span></code>,
and <code class="docutils literal notranslate"><span class="pre">f</span></code>
are all <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> arrays — <code class="docutils literal notranslate"><span class="pre">dx2[:]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[d,</span> <span class="pre">:]</span></code>, and <code class="docutils literal notranslate"><span class="pre">f[:]</span></code> —
so that the entire batch of integration points is processed at the same
time. The array returned by <code class="docutils literal notranslate"><span class="pre">f_rbatch(x)</span></code> has an additional index
(on the right) labeling the integration point.</p>
<p>The batch integrands above have the batch index in the last/rightmost
position.
It is sometimes more convenient to have the batch index
be the first/leftmost index
rather than the last. Then <code class="docutils literal notranslate"><span class="pre">&#64;vegas.rbatchintegrand</span></code> should be
replaced by <code class="docutils literal notranslate"><span class="pre">&#64;vegas.lbatchintegrand</span></code>, and <code class="docutils literal notranslate"><span class="pre">vegas.RBatchIntegrand</span></code> by
<code class="docutils literal notranslate"><span class="pre">vegas.LBatchIntegrand</span></code>. The <code class="docutils literal notranslate"><span class="pre">lbatch</span></code> version of the integrand <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>
above is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@vegas</span><span class="o">.</span><span class="n">lbatchintegrand</span>
<span class="k">def</span> <span class="nf">f_lbatch</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">ans</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">ans</span>
</pre></div>
</div>
<p>Note where the batch index must be explicit here (<code class="docutils literal notranslate"><span class="pre">x[:,d]</span></code> and <code class="docutils literal notranslate"><span class="pre">ans[:,</span> <span class="pre">n]</span></code>),
unlike in the <code class="docutils literal notranslate"><span class="pre">rbatch</span></code> version.</p>
<p>The batch integrands above are fast because they are expressed in terms of
<code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> operators that act on entire arrays.
That optimization is not always possible or simple. It is unnecessary if
we use the <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> Python module to compile the integrand. Returning
to the <code class="docutils literal notranslate"><span class="pre">ridge</span></code> integral above, for example, a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> implementation
would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numba</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">lbatchintegrand</span>
<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span>
<span class="k">def</span> <span class="nf">ridge</span><span class="p">(</span><span class="n">xbatch</span><span class="p">):</span>
    <span class="s2">&quot; Ridge of N Gaussians distributed along part of the diagonal. &quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">xbatch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xbatch</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xbatch</span><span class="p">)):</span>
        <span class="c1"># iterate over each integration point x in xbatch</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xbatch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">j</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">norm</span>
    <span class="k">return</span> <span class="n">ans</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">warmup</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">   Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>Here the decorator <code class="docutils literal notranslate"><span class="pre">&#64;numba.njit</span></code> causes the <code class="docutils literal notranslate"><span class="pre">ridge</span></code> function to be
compiled into efficient machine code the first time it is called, and
the machine code is used in place of the Python function for that
and all subsequent calls. <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> is particularly effective when
compiling low-level code such as this, where standard numerical
datatypes (integers, floats) are manipulated directly (rather than
relying on <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> array operations). This code is somewhat
faster than the batch integrands above that use <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> array
arithmetic (15 sec versus 20 sec).</p>
<p>There are a variety of other ways to create optimized codes using
compilers. Some of these are discussed below in the section on
<a class="reference internal" href="compiled_integrands.html#compiled-integrands"><span class="std std-ref">Compiled Integrands for Speed; GPUs</span></a>.</p>
</section>
<section id="multiple-processors">
<h2>Multiple Processors<a class="headerlink" href="#multiple-processors" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> supports parallel evaluation of integrands
on multiple processors. This
can shorten execution time substantially when the integrand is
costly to evaluate. Returning to the <code class="docutils literal notranslate"><span class="pre">ridge</span></code> example from the
previous section, the following code
runs almost six times faster
when using <code class="docutils literal notranslate"><span class="pre">nproc=8</span></code> processors instead of the
default <code class="docutils literal notranslate"><span class="pre">nproc=1</span></code> (on a 2024 laptop):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">rbatchintegrand</span>
<span class="k">def</span> <span class="nf">ridge</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s2">&quot; Ridge of N Gaussians distributed along part of the diagonal. &quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x0</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">norm</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  <span class="c1"># 8 processors</span>
    <span class="n">warmup</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>One might have expected the code to run eight times faster
(instead of six), but it takes time to
initiate the <code class="docutils literal notranslate"><span class="pre">nproc</span></code> processes, and to feed data and
collect results from them.
Parallel processing only becomes useful when integrands are
sufficiently costly that such overheads become negligible.</p>
<p>Parallel processing is managed by Python’s
<code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> module.
The <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> construct at the end of
this code is essential when running on Windows or MacOS (in its
default mode) as it prevents additional processes being launched
when the main module is imported as part of spawning the <code class="docutils literal notranslate"><span class="pre">nproc</span></code>
processes; see the <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> documentation for more
details. This is not an issue for Linux/Unix. It is also important
that the integrand and its return values can be pickled using
Python’s <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> module. This is the case for most pure
Python integrands.</p>
<p>The code above will generate an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> when run in some
interactive environments (as opposed to running from the command line)
on some platforms. This can usually be fixed by putting the integrand
function <code class="docutils literal notranslate"><span class="pre">ridge(x)</span></code> into a file and importing it into the script.</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> also supports multi-processor evaluation of integrands using MPI
(via the Python module <code class="xref py py-mod docutils literal notranslate"><span class="pre">mpi4py</span></code> which must be installed separately).
Placing the code above in a file <code class="docutils literal notranslate"><span class="pre">ridge.py</span></code>, with <code class="docutils literal notranslate"><span class="pre">mpi=True</span></code> set
in the integrator (and with <code class="docutils literal notranslate"><span class="pre">nproc=1</span></code> or unset) —</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">mpi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>— <code class="docutils literal notranslate"><span class="pre">ridge.py</span></code> can be run on 8 processors using</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">8</span> <span class="n">python</span> <span class="n">ridge</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>The speedup is similar to that from using the
<code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> module, above.
Note that the random number generator used by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> must be
synchronized so that it
produces the same random numbers on the different processors. This
happens automatically for the default random-number generator.</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s batch mode makes it possible to implement other strategies
for distributing integrand evaluations across multiple processors.
For example, <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> provides support for
parallel evaluation of specific loops. The <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> version
of the <code class="docutils literal notranslate"><span class="pre">ridge</span></code> integrand (see previous section) can be
rewritten</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">lbatchintegrand</span>
<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ridge</span><span class="p">(</span><span class="n">xbatch</span><span class="p">):</span>
    <span class="s2">&quot; Ridge of N Gaussians distributed along part of the diagonal. &quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">xbatch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xbatch</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numba</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xbatch</span><span class="p">)):</span>
        <span class="c1"># iterate over each integration point x in xbatch</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xbatch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">j</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">norm</span>
    <span class="k">return</span> <span class="n">ans</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  <span class="c1"># leave nproc unset</span>
                                        <span class="c1"># parallelization handled by ridge(x)</span>

<span class="n">warmup</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">2e5</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">   Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>where function <code class="docutils literal notranslate"><span class="pre">numba.prange</span></code> is used instead of Python’s <code class="docutils literal notranslate"><span class="pre">range</span></code> function to
indicate that different iterations of the loop can be run in parallel
on multiple processors. <code class="xref py py-mod docutils literal notranslate"><span class="pre">numba</span></code> uses
all processors available. The speedup for this example is similar to that using
the other multi-processor methods above.</p>
<p>As another example exploiting <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s batch mode,
we can create a class <code class="docutils literal notranslate"><span class="pre">parallelintegrand</span></code>
whose function is similar to decorator <a class="reference internal" href="vegas.html#vegas.lbatchintegrand" title="vegas.lbatchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.lbatchintegrand()</span></code></a>,
but where Python’s
<code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> module provides parallel processing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vegas</span>

<span class="k">class</span> <span class="nc">parallelintegrand</span><span class="p">(</span><span class="n">vegas</span><span class="o">.</span><span class="n">LBatchIntegrand</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Convert (batch) integrand into multiprocessor integrand.</span>

<span class="sd">    Integrand should return a numpy array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="s2">&quot; Save integrand; create pool of nproc processes. &quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fcn</span> <span class="o">=</span> <span class="n">fcn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot; Standard cleanup. &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot; Divide x into self.nproc chunks, feeding one to each process. &quot;</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># launch evaluation of self.fcn for each chunk, in parallel</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fcn</span><span class="p">,</span>
            <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nx</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="p">)],</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># convert list of results into a single numpy array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>Then <code class="docutils literal notranslate"><span class="pre">fparallel</span> <span class="pre">=</span> <span class="pre">parallelintegrand(f,</span> <span class="pre">4)</span></code>, for example, will create a
new integrand <code class="docutils literal notranslate"><span class="pre">fparallel(x)</span></code> that uses 4 CPU cores.</p>
</section>
<section id="sums-with-vegas">
<h2>Sums with <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a><a class="headerlink" href="#sums-with-vegas" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ridge</span></code> code in the previous sections is inefficient in the way it
handles the sum over <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1000</span></code> Gaussians. It is not necessary to include every
term in the sum for every integration point. Rather we can sample the sum,
using <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to do the sampling. The trick is to replace the sum with
an equivalent integral:</p>
<div class="math">
<p><img src="_images/math/4ab87bac1cabadedb6adf39caeebef3b48e76c61.svg" alt="\frac{1}{N}\sum_{i=0}^{N-1} f(i) = \int_0^1 dx \; f(\mathrm{floor}(x N))"/></p>
</div><p>where <img class="math" src="_images/math/a5edf0b2302db13bc83f0cec6d411c70f1a4334e.svg" alt="\mathrm{floor}(x)"/> is the largest
integer smaller than <img class="math" src="_images/math/ab7f1721dbcf7398485913e30d2b94b3632ff40c.svg" alt="x"/>. The
resulting integral can then be handed to <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>.</p>
<p>Using this trick,
the batch version of <code class="docutils literal notranslate"><span class="pre">ridge</span></code> integral from <a class="reference internal" href="#faster-integrands"><span class="std std-ref">Faster Integrands</span></a> can
be re-cast as a 5-dimensional
integral, where the integral over <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> does the sum over Gaussians:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">rbatchintegrand</span>
<span class="k">def</span> <span class="nf">ridge</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Ridge of N Gaussians distributed along part of the diagonal.</span>

<span class="sd">    Gaussians are at points x0[d]  = 0.25 + 0.5 * i /(N-1) for</span>
<span class="sd">    all directions d and Gaussians i=0...N-1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">dim</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">warmup</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">8e5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">8e5</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">   Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>This code gives a result with the same precision as the earlier (batch)
integral, but is 20 times faster (1 sec versus 20 sec).</p>
<p>The same trick can be generalized to sums over multiple indices, including sums
to infinity. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> will provide Monte Carlo estimates of the sums, emphasizing
the more important terms.</p>
</section>
<section id="saving-results-automatically">
<h2>Saving Results Automatically<a class="headerlink" href="#saving-results-automatically" title="Link to this heading">¶</a></h2>
<p>Results returned by a <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> integrator can be pickled for later use using <code class="docutils literal notranslate"><span class="pre">pickle.dump/load</span></code> (or
<code class="docutils literal notranslate"><span class="pre">gvar.dump/load</span></code>) in the usual way. Results can also be saved automatically using the
<code class="docutils literal notranslate"><span class="pre">save</span></code> keyword to specify a file name for the pickled result: for example, running</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1013.2118364296088</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="s1">&#39;save.pkl&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>prints out</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.00050</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>     <span class="mf">0.00050</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>         <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.115</span><span class="p">(</span><span class="mi">59</span><span class="p">)</span>       <span class="mf">0.00051</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>         <span class="mf">3.77</span>     <span class="mf">0.05</span>
  <span class="mi">3</span>   <span class="mf">0.66</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>        <span class="mf">0.00051</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>         <span class="mf">6.41</span>     <span class="mf">0.00</span>
  <span class="mi">4</span>   <span class="mf">0.72</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>        <span class="mf">0.00052</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>        <span class="mf">12.27</span>     <span class="mf">0.00</span>
  <span class="mi">5</span>   <span class="mf">0.97</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>        <span class="mf">0.00053</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>        <span class="mf">26.17</span>     <span class="mf">0.00</span>
  <span class="mi">6</span>   <span class="mf">1.045</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>       <span class="mf">0.00059</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>        <span class="mf">79.46</span>     <span class="mf">0.00</span>
  <span class="mi">7</span>   <span class="mf">1.016</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>       <span class="mf">0.00069</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>       <span class="mf">152.45</span>     <span class="mf">0.00</span>
  <span class="mi">8</span>   <span class="mf">1.023</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>       <span class="mf">0.00093</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>       <span class="mf">307.32</span>     <span class="mf">0.00</span>
  <span class="mi">9</span>   <span class="mf">0.999</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">0.00141</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>       <span class="mf">573.82</span>     <span class="mf">0.00</span>
 <span class="mi">10</span>   <span class="mf">1.025</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">0.00208</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>       <span class="mf">896.20</span>     <span class="mf">0.00</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">0.00208</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.00</span>
</pre></div>
</div>
<p>but also stores <code class="docutils literal notranslate"><span class="pre">result</span></code> in file <code class="docutils literal notranslate"><span class="pre">save.pkl</span></code>. The result can be retrieved
later using, for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;save.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>which gives exactly the same output.</p>
<p>This feature is most useful for expensive integrations, ones taking minutes or hours
to complete. This is because the pickled file is updated after every <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
iteration. This means that a short script like the one above can be used to
monitor progress before the integration is finished. It also means that results
up through the most recent iteration are saved even if the integration is
terminated early or crashes.</p>
<p>Saved results are also useful because they can be fixed after the code has
finished running.
The early iterations in the output above are clearly wrong
and badly distort the weighted average. The problem is that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> isn’t well
adapted to the integrand until around the fifth or sixth iteration. We
can discard the first five iterations (from the saved result)
by using function <a class="reference internal" href="vegas.html#vegas.ravg" title="vegas.ravg"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.ravg()</span></code></a>
to redo the weighted average:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">vegas</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;save.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">ravg</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">itn_results</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>This gives the following output</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">1.045</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>       <span class="mf">1.045</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.016</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>       <span class="mf">1.026</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>           <span class="mf">0.14</span>     <span class="mf">0.71</span>
  <span class="mi">3</span>   <span class="mf">1.023</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>       <span class="mf">1.024</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>           <span class="mf">0.07</span>     <span class="mf">0.93</span>
  <span class="mi">4</span>   <span class="mf">0.999</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">1.010</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>           <span class="mf">0.28</span>     <span class="mf">0.84</span>
  <span class="mi">5</span>   <span class="mf">1.025</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">1.017</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.31</span>     <span class="mf">0.87</span>

<span class="n">result</span> <span class="o">=</span> <span class="mf">1.017</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.87</span>
</pre></div>
</div>
<p>which is greatly improved over the original.</p>
<p>It is also possible to save an adapted integrator using <code class="docutils literal notranslate"><span class="pre">pickle.dump/load</span></code>
(or <code class="docutils literal notranslate"><span class="pre">gvar.dump/load</span></code>). This can also be done automatically, by
replacing, for example, <code class="docutils literal notranslate"><span class="pre">save='save.pkl'</span></code> with <code class="docutils literal notranslate"><span class="pre">saveall='saveall.pkl'</span></code>
in the script above. The pickled file then returns a tuple containing
the most recent <code class="docutils literal notranslate"><span class="pre">result</span></code> and <code class="docutils literal notranslate"><span class="pre">integ</span></code>. Having the (adapted) integrator,
it is possible to further refine a result later: for example, running</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1013.2118364296088</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;saveall.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">integ</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">ravg</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">itn_results</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span>

<span class="n">new_result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">New results:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">new_result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Combined results:&#39;</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Combined result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
<p>significantly improves the final result by adding 5   additional
iterations
to what was done  earlier. The new iterations are in <code class="docutils literal notranslate"><span class="pre">new_result</span></code>
and tabulated under “New Results” in the output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="n">New</span> <span class="n">results</span><span class="p">:</span>
<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">1.007</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">1.007</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.006</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>       <span class="mf">1.007</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">0.98</span>
  <span class="mi">3</span>   <span class="mf">0.997</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>       <span class="mf">1.0029</span><span class="p">(</span><span class="mi">82</span><span class="p">)</span>          <span class="mf">0.16</span>     <span class="mf">0.85</span>
  <span class="mi">4</span>   <span class="mf">1.015</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>       <span class="mf">1.0044</span><span class="p">(</span><span class="mi">76</span><span class="p">)</span>          <span class="mf">0.20</span>     <span class="mf">0.90</span>
  <span class="mi">5</span>   <span class="mf">0.990</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>       <span class="mf">1.0007</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>          <span class="mf">0.39</span>     <span class="mf">0.82</span>


<span class="n">Combined</span> <span class="n">results</span><span class="p">:</span>
<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">1.045</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>       <span class="mf">1.045</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.016</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>       <span class="mf">1.026</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>           <span class="mf">0.14</span>     <span class="mf">0.71</span>
  <span class="mi">3</span>   <span class="mf">1.023</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>       <span class="mf">1.024</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>           <span class="mf">0.07</span>     <span class="mf">0.93</span>
  <span class="mi">4</span>   <span class="mf">0.999</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">1.010</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>           <span class="mf">0.28</span>     <span class="mf">0.84</span>
  <span class="mi">5</span>   <span class="mf">1.025</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">1.017</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.31</span>     <span class="mf">0.87</span>
  <span class="mi">6</span>   <span class="mf">1.007</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">1.0136</span><span class="p">(</span><span class="mi">94</span><span class="p">)</span>          <span class="mf">0.30</span>     <span class="mf">0.91</span>
  <span class="mi">7</span>   <span class="mf">1.006</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>       <span class="mf">1.0114</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>          <span class="mf">0.28</span>     <span class="mf">0.95</span>
  <span class="mi">8</span>   <span class="mf">0.997</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>       <span class="mf">1.0076</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>          <span class="mf">0.36</span>     <span class="mf">0.92</span>
  <span class="mi">9</span>   <span class="mf">1.015</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>       <span class="mf">1.0082</span><span class="p">(</span><span class="mi">63</span><span class="p">)</span>          <span class="mf">0.33</span>     <span class="mf">0.95</span>
 <span class="mi">10</span>   <span class="mf">0.990</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>       <span class="mf">1.0047</span><span class="p">(</span><span class="mi">57</span><span class="p">)</span>          <span class="mf">0.48</span>     <span class="mf">0.89</span>

<span class="n">Combined</span> <span class="n">result</span> <span class="o">=</span> <span class="mf">1.0047</span><span class="p">(</span><span class="mi">57</span><span class="p">)</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.89</span>
</pre></div>
</div>
<p>The new results are merged onto the end of the original results using
<code class="docutils literal notranslate"><span class="pre">result.extend(new_result)</span></code> to obtain the combined results from all
10   iterations (old plus new).</p>
<p>Saving integrators is again useful for costly
integrations that might need to be restarted later since the saved integrator
remembers the variable transformations made to minimize errors, and
so need not be readapted to the integrand when used again. The resulting
pickle file can be large, however, particularly if <code class="docutils literal notranslate"><span class="pre">neval</span></code> is large.
The (adapted) <a class="reference internal" href="vegas.html#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a> <code class="docutils literal notranslate"><span class="pre">integ.map</span></code> can also
be pickled by itself and results in a smaller file.</p>
</section>
<section id="vegas-maps-and-preconditioning-vegas">
<h2><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Maps and Preconditioning <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a><a class="headerlink" href="#vegas-maps-and-preconditioning-vegas" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts by remapping the integration variables (see <a class="reference internal" href="background.html#importance-sampling"><span class="std std-ref">Importance Sampling</span></a>). It
is possible to precondition this map, before creating a <a class="reference internal" href="vegas.html#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a>.
Preconditioned maps can improve <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> results when
much is known about the integrand ahead of time. Consider,
for example, the integral</p>
<div class="math">
<p><img src="_images/math/721b44b77eb2a14f226faefe482bb91362cc29b3.svg" alt="C\int_0^1 \!d^5x\,
\,\sum_{i=1}^2 \mathrm{e}^{-50 |\mathbf{x} - \mathbf{r}_i|},"/></p>
</div><p>which has high, narrow peaks at</p>
<div class="math">
<p><img src="_images/math/9be1b594a582b717e0f1023fc848342229e02050.svg" alt="\mathbf{r}_1 = (0.45, 0.45, 0.45, 0.45, 0.45),"/></p>
</div><div class="math">
<p><img src="_images/math/37d329e244c9cc941241cf13f2af6e674ce4490f.svg" alt="\mathbf{r}_2 = (0.7, 0.7, 0.7, 0.7, 0.7)."/></p>
</div><p>Given the locations of the peaks we can create a <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> map before integrating
that emphasizes the regions around them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">batchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.45</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]:</span>
        <span class="n">dx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ans</span> <span class="o">*</span> <span class="mf">247366.171</span>

<span class="n">dim</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">AdaptiveMap</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>     <span class="c1"># uniform map</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>                        <span class="c1"># 2000 points near peaks</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.45</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">3</span><span class="o">/</span><span class="mi">50</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">dim</span><span class="p">)),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">3</span><span class="o">/</span><span class="mi">50</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">dim</span><span class="p">)),</span>
    <span class="p">])</span>
<span class="nb">map</span><span class="o">.</span><span class="n">adapt_to_samples</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>       <span class="c1"># precondition map</span>
<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
</pre></div>
</div>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> maps are objects of type <a class="reference internal" href="vegas.html#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a>. Here we
create a uniform map object <code class="docutils literal notranslate"><span class="pre">map</span></code>. We then
generate 2000 random points <code class="docutils literal notranslate"><span class="pre">x</span></code> from normal distributions centered around
the peak locations. <code class="docutils literal notranslate"><span class="pre">map.adapt_to_samples(x,</span> <span class="pre">f(x),</span> <span class="pre">nitn=5)</span></code> optimizes
the map for integrating <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> based on information about the integrand
at the random
points <code class="docutils literal notranslate"><span class="pre">x</span></code>. As a result, <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is almost fully adapted to the
integrand already in its first iteration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.981</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>       <span class="mf">0.981</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.983</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>       <span class="mf">0.9825</span><span class="p">(</span><span class="mi">98</span><span class="p">)</span>          <span class="mf">0.00</span>     <span class="mf">0.96</span>
  <span class="mi">3</span>   <span class="mf">1.001</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>       <span class="mf">0.9915</span><span class="p">(</span><span class="mi">71</span><span class="p">)</span>          <span class="mf">0.85</span>     <span class="mf">0.43</span>
  <span class="mi">4</span>   <span class="mf">1.000</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>       <span class="mf">0.9933</span><span class="p">(</span><span class="mi">63</span><span class="p">)</span>          <span class="mf">0.67</span>     <span class="mf">0.57</span>
  <span class="mi">5</span>   <span class="mf">0.993</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>       <span class="mf">0.9931</span><span class="p">(</span><span class="mi">54</span><span class="p">)</span>          <span class="mf">0.50</span>     <span class="mf">0.74</span>

</pre></div>
</div>
<p>We set <code class="docutils literal notranslate"><span class="pre">alpha=0</span></code> in the integrator to prevent
further changes to the pre-adapted map.</p>
<p>These results can be contrasted with what happens without preconditioning, where
the integrator is still far from converged by the fifth iteration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.74</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>        <span class="mf">0.74</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>            <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.93</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>        <span class="mf">0.90</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>            <span class="mf">0.38</span>     <span class="mf">0.54</span>
  <span class="mi">3</span>   <span class="mf">0.94</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>        <span class="mf">0.920</span><span class="p">(</span><span class="mi">74</span><span class="p">)</span>           <span class="mf">0.23</span>     <span class="mf">0.79</span>
  <span class="mi">4</span>   <span class="mf">1.091</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>       <span class="mf">1.004</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span>           <span class="mf">1.03</span>     <span class="mf">0.38</span>
  <span class="mi">5</span>   <span class="mf">1.063</span><span class="p">(</span><span class="mi">58</span><span class="p">)</span>       <span class="mf">1.031</span><span class="p">(</span><span class="mi">39</span><span class="p">)</span>           <span class="mf">0.91</span>     <span class="mf">0.46</span>

</pre></div>
</div>
<p>The exact distribution of random points <code class="docutils literal notranslate"><span class="pre">x</span></code> isn’t important; what
matters is that they cover and are concentrated in
the dominant regions contributing to the integral. Should it be needed,
a sample <code class="docutils literal notranslate"><span class="pre">xsample=(x,</span> <span class="pre">f(x))</span></code>
in <code class="docutils literal notranslate"><span class="pre">x</span></code>-space is easily converted to the equivalent sample in <code class="docutils literal notranslate"><span class="pre">y</span></code>-space using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">xsample</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
<span class="nb">map</span><span class="o">.</span><span class="n">invmap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">jac</span><span class="p">)</span>
<span class="n">ysample</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">jac</span> <span class="o">*</span> <span class="n">fx</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">map.invmap(x,</span> <span class="pre">y,</span> <span class="pre">jac)</span></code> fills array <code class="docutils literal notranslate"><span class="pre">y</span></code> with the <code class="docutils literal notranslate"><span class="pre">y</span></code>-space
points corresponding to <code class="docutils literal notranslate"><span class="pre">x</span></code>, and array <code class="docutils literal notranslate"><span class="pre">jac</span></code> with the transformation’s
Jacobian.</p>
<p>Note that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> maps can be used with integrators other than <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>.
The <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> map maps the integration variables <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> into
new variables <code class="docutils literal notranslate"><span class="pre">y[d]</span></code> (where <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">y[d]</span> <span class="pre">&lt;</span> <span class="pre">1</span></code>) that make the integrand
easier to integrate. The integrator is used
to evaluate the integral in <code class="docutils literal notranslate"><span class="pre">y</span></code>-space. To illustrate how this
works, we replace the last three lines of the code at the start of
this section with
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">smc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="s2">&quot; integrates f(y) over dim-dimensional unit hypercube &quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">neval</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">fy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">fy</span><span class="p">)</span> <span class="o">/</span> <span class="n">neval</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="nb">map</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">jac</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jac</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># with map</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">smc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">50_000</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   SMC + map:&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> +- </span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># without map</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">smc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">50_000</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SMC (no map):&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> +- </span><span class="si">{</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">smc</span></code> is a Simple Monte Carlo (SMC) integrator and <code class="docutils literal notranslate"><span class="pre">g(y)</span></code> is the
integrand in <code class="docutils literal notranslate"><span class="pre">y</span></code>-space that corresponds to <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> in <code class="docutils literal notranslate"><span class="pre">x</span></code>-space.
The mapping is done by <code class="docutils literal notranslate"><span class="pre">map.map(y,</span> <span class="pre">x,</span> <span class="pre">jac)</span></code> which fills the arrays
<code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">jac</span></code> with the <code class="docutils literal notranslate"><span class="pre">x</span></code> values and Jacobian corresponding
to integration points <code class="docutils literal notranslate"><span class="pre">y</span></code>. The result is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">SMC</span> <span class="o">+</span> <span class="nb">map</span><span class="p">:</span> <span class="mf">1.013</span> <span class="o">+-</span> <span class="mf">0.020</span>
<span class="n">SMC</span> <span class="p">(</span><span class="n">no</span> <span class="nb">map</span><span class="p">):</span> <span class="mf">1.703</span> <span class="o">+-</span> <span class="mf">0.535</span>
</pre></div>
</div>
<p>where we give results from SMC with and without using
the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> map. The <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> map greatly improves
the SMC result, which, not surprisingly, is significantly
less accurate the the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> result above.
Maps for use with other integrators can be built
directly, as above, or they can be built for a particular
integrand by running several iterations of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> with
the integrand and using the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> integrator’s map: <code class="docutils literal notranslate"><span class="pre">integ.map</span></code>.</p>
</section>
<section id="vegas-stratifications">
<h2><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Stratifications<a class="headerlink" href="#vegas-stratifications" title="Link to this heading">¶</a></h2>
<p>Having mapped the integration variables <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> to new variables <code class="docutils literal notranslate"><span class="pre">y[d]</span></code>,
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> evaluates the integral in <code class="docutils literal notranslate"><span class="pre">y</span></code>-space using stratified Monte
Carlo sampling (see <a class="reference internal" href="background.html#adaptive-stratified-sampling"><span class="std std-ref">Adaptive Stratified Sampling</span></a>). This is
done by dividing each axis <code class="docutils literal notranslate"><span class="pre">d</span></code> into <code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> equal strata,
which divide the <code class="docutils literal notranslate"><span class="pre">D</span></code>-dimensional integration volume into
<code class="docutils literal notranslate"><span class="pre">prod(nstrat)</span></code> sub-volumes or (rectangular) hypercubes. <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> does a
separate integral
in each hypercube, adjusting the number of integrand evaluations
used in each one to minimize errors. By default, the number of
strata in each direction is set automatically based on the number
<code class="docutils literal notranslate"><span class="pre">neval</span></code> of integrand evaluations per iteration: <code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> is set
equal to <img class="math" src="_images/math/4c86252f32d131a8f44f26758116800882fcdd96.svg" alt="M_\mathrm{st}+1"/> for the first <img class="math" src="_images/math/7321a4e74c1565fae8df6410c912914eb8e26628.svg" alt="D_0"/> directions
and <img class="math" src="_images/math/73d8c1ea5fd68b2fb5ced2dcbe4d7fa7560543c8.svg" alt="M_\mathrm{st}"/> for
the remaining directions, where <img class="math" src="_images/math/73d8c1ea5fd68b2fb5ced2dcbe4d7fa7560543c8.svg" alt="M_\mathrm{st}"/>
and <img class="math" src="_images/math/7321a4e74c1565fae8df6410c912914eb8e26628.svg" alt="D_0"/> are chosen
to maximize the number strata consistent with <code class="docutils literal notranslate"><span class="pre">neval</span></code>.
It is also possible, however, to specify the number of
strata <code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> for each direction separately.</p>
<p>Requiring (approximately) the same number of strata in each direction
greatly limits the number of strata per direction in very high
dimensions, since the product of the <code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> must be
less than <code class="docutils literal notranslate"><span class="pre">neval/2</span></code> (so there are at least two integrand
samples in each hypercube). This restricts <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s ability to
adapt. Often there is a subset of integration directions
that are more challenging than the others. In high
dimensions (and possibly lower dimensions)
it is worthwhile using larger values
for <code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> for those directions.</p>
<p>An example is the 20-dimensional integral</p>
<div class="math">
<p><img src="_images/math/4cbd656a936928ee266d7fbb4c91f4d930093a64.svg" alt="C\int_0^1 \!d^{20}x\,
\,\sum_{i=1}^3 \mathrm{e}^{-100 (\mathbf{x} - \mathbf{r}_i)^2},"/></p>
</div><p>which has high, narrow peaks at</p>
<div class="math">
<p><img src="_images/math/d4f7a60234de384939a7339f7dcf857e7e70574e.svg" alt="\mathbf{r}_1 = (0.23, 0.23, 0.23, 0.23, 0.23, 0.45, \ldots, 0.45),"/></p>
</div><div class="math">
<p><img src="_images/math/c23804d04a86b92acee6aec7bdd3c5ad91d08bf2.svg" alt="\mathbf{r}_2 = (0.39, 0.39, 0.39, 0.39, 0.39, 0.45, \ldots, 0.45),"/></p>
</div><div class="math">
<p><img src="_images/math/4106b88d732927357e6da91b3153720979f97316.svg" alt="\mathbf{r}_3 = (0.74, 0.74, 0.74, 0.74, 0.74, 0.45, \ldots, 0.45)."/></p>
</div><p>These peaks are aligned along the diagonal of the integration volume for the
first five directions, but are on top of each other in the remaining directions.
This makes the integrals over the first five directions much more challenging
than the remaining integrals.</p>
<p>The following code compares an integral that uses the default stratification
from <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> with one that concentrates all of the strata in the first
five directions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">dim</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">rlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="mi">5</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.23</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.45</span><span class="p">],</span>
    <span class="mi">5</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.39</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.45</span><span class="p">],</span>
    <span class="mi">5</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.74</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.45</span><span class="p">],</span>
    <span class="p">])</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">batchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rlist</span><span class="p">:</span>
        <span class="n">dx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span> <span class="o">*</span> <span class="mf">356047712484621.56</span>

<span class="n">nitn</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">neval</span> <span class="o">=</span> <span class="mf">2e6</span>
<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>        <span class="c1"># training</span>

<span class="c1"># default stratification</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="n">nitn</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;DEFAUlT:   nstrat = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">nstrat</span><span class="p">)</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">nstrat</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

<span class="c1"># stratification concentrated in first 5 directions</span>
<span class="n">nstrat</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="n">neval</span><span class="p">,</span> <span class="n">nstrat</span><span class="o">=</span><span class="n">nstrat</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MODFIED:   nstrat = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">nstrat</span><span class="p">)</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">nstrat</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
</pre></div>
</div>
<p>This code generates the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DEFAULT</span><span class="p">:</span>   <span class="n">nstrat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="mi">131072</span><span class="p">)</span>
<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.999</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>       <span class="mf">0.999</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.023</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>       <span class="mf">1.0107</span><span class="p">(</span><span class="mi">79</span><span class="p">)</span>          <span class="mf">2.40</span>     <span class="mf">0.12</span>
  <span class="mi">3</span>   <span class="mf">0.9922</span><span class="p">(</span><span class="mi">93</span><span class="p">)</span>      <span class="mf">1.0029</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>          <span class="mf">2.37</span>     <span class="mf">0.09</span>
  <span class="mi">4</span>   <span class="mf">1.0054</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span>      <span class="mf">1.0037</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>          <span class="mf">1.60</span>     <span class="mf">0.19</span>
  <span class="mi">5</span>   <span class="mf">1.0054</span><span class="p">(</span><span class="mi">88</span><span class="p">)</span>      <span class="mf">1.0041</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>          <span class="mf">1.20</span>     <span class="mf">0.31</span>

<span class="n">MODIFIED</span><span class="p">:</span>   <span class="n">nstrat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">10</span> <span class="mi">10</span> <span class="mi">10</span> <span class="mi">10</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">1.0045</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>      <span class="mf">1.0045</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>          <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.99968</span><span class="p">(</span><span class="mi">87</span><span class="p">)</span>     <span class="mf">1.00016</span><span class="p">(</span><span class="mi">83</span><span class="p">)</span>         <span class="mf">3.02</span>     <span class="mf">0.08</span>
  <span class="mi">3</span>   <span class="mf">0.9994</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>      <span class="mf">0.99986</span><span class="p">(</span><span class="mi">65</span><span class="p">)</span>         <span class="mf">1.68</span>     <span class="mf">0.19</span>
  <span class="mi">4</span>   <span class="mf">0.99940</span><span class="p">(</span><span class="mi">67</span><span class="p">)</span>     <span class="mf">0.99964</span><span class="p">(</span><span class="mi">47</span><span class="p">)</span>         <span class="mf">1.20</span>     <span class="mf">0.31</span>
  <span class="mi">5</span>   <span class="mf">0.99957</span><span class="p">(</span><span class="mi">56</span><span class="p">)</span>     <span class="mf">0.99961</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>         <span class="mf">0.90</span>     <span class="mf">0.46</span>

</pre></div>
</div>
<p>The default stratification has 2 strata in almost every direction, while the
modified stratification has 10 strata in each of the first 5 directions, but
only 1 in all other directions. The latter is 10–15 times more accurate.</p>
<p>In more realistic examples, we may not know which are the most challenging directions;
then function <a class="reference internal" href="vegas.html#vegas.restratify" title="vegas.restratify"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.restratify()</span></code></a> might be useful. This function tries
to determine which directions are more challenging than others, and uses this
information to create an new integrator with a stratification that emphasizes
the more difficult directions. Replacing the
last block of code in the example above with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># automatic re-stratification</span>
<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">restratify</span><span class="p">(</span><span class="n">integ</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MODIFIED:   nstrat = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">nstrat</span><span class="p">)</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">nstrat</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
</pre></div>
</div>
<p>gives in the following result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MODIFIED</span><span class="p">:</span>   <span class="n">nstrat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span>  <span class="mi">9</span> <span class="mi">13</span>  <span class="mi">9</span> <span class="mi">10</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span>  <span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="mi">126360</span><span class="p">)</span>
<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.99823</span><span class="p">(</span><span class="mi">93</span><span class="p">)</span>     <span class="mf">0.99823</span><span class="p">(</span><span class="mi">93</span><span class="p">)</span>         <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.00007</span><span class="p">(</span><span class="mi">85</span><span class="p">)</span>     <span class="mf">0.99923</span><span class="p">(</span><span class="mi">63</span><span class="p">)</span>         <span class="mf">2.14</span>     <span class="mf">0.14</span>
  <span class="mi">3</span>   <span class="mf">0.99903</span><span class="p">(</span><span class="mi">62</span><span class="p">)</span>     <span class="mf">0.99913</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>         <span class="mf">1.10</span>     <span class="mf">0.33</span>
  <span class="mi">4</span>   <span class="mf">0.99939</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>     <span class="mf">0.99922</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>         <span class="mf">0.77</span>     <span class="mf">0.51</span>
  <span class="mi">5</span>   <span class="mf">0.99876</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>     <span class="mf">0.99910</span><span class="p">(</span><span class="mi">31</span><span class="p">)</span>         <span class="mf">0.68</span>     <span class="mf">0.60</span>

</pre></div>
</div>
<p>The modified code replaces integrator <cite>integ</cite> by a new integrator with an improved
stratification, which turns out to be quite similar to the improved stratification
we used above. Again results are more than ten times as accurate as with
the default stratification.</p>
</section>
<section id="vegas-jacobian">
<span id="id4"></span><h2><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Jacobian<a class="headerlink" href="#vegas-jacobian" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Jacobian is useful when integrating multiple integrands simultaneously
when some of the integrands depend only on a subset of the integration variables.</p>
<p>Consider, for example, the integral</p>
<div class="math">
<p><img src="_images/math/3890847c19e053620c346df97a4f497f57370dd7.svg" alt="\int^{\pi/2}_0 dx_0 \, \frac{1}{(x_0-\delta)^2 + 0.01}."/></p>
</div><p>We want to compare this integral for two different cases: a)
where <img class="math" src="_images/math/02c4a20bde8b055bb7b6f51cceaac435da16ff4a.svg" alt="\delta=x_1"/> is a random number near zero drawn from a distribution
proportional to <img class="math" src="_images/math/bcab076307ff41e86010879301646afde5dd2f53.svg" alt="\mathrm{exp}(-100\, \mathrm{sin} (x_1))"/>
with <img class="math" src="_images/math/271cf2288236b608b35028228f2d4d897d477529.svg" alt="0\le x_1 \le \pi/2"/>;
and b) where <img class="math" src="_images/math/b39c8a1091721593433ecb77fd97cb4649579207.svg" alt="\delta=0"/>. The result for the first case is
<img class="math" src="_images/math/3454d807ce969cbcc21b7df83c286b4782adff5f.svg" alt="I_a = I_a^\mathrm{num}/I_a^\mathrm{den}"/> where</p>
<div class="math">
<p><img src="_images/math/d8b94a9767baec34910969270fb1b59f15bc82ae.svg" alt="I_a^\mathrm{num} &amp;= \int^{\pi/2}_0 dx_0 \int^{\pi/2}_0 dx_1
\, \mathrm{e}^{-100\,\mathrm{sin}(x_1)}
 \, \frac{1}{(x_0-x_1)^2 + 0.01} \\
I_a^\mathrm{den} &amp;= \int^{\pi/2}_0 dx_1
\, \mathrm{e}^{-100 \,\mathrm{sin}(x_1)}."/></p>
</div><p>The result for the second case is</p>
<div class="math">
<p><img src="_images/math/6ceb0dc78c1893847595d3be7fdca125133b57cc.svg" alt="I_b = \int^{\pi/2}_0 dx_0
\, \frac{1}{(x_0)^2 + 0.01}."/></p>
</div><p>The first two integrals should have very similar dependence on <img class="math" src="_images/math/fd08d489b27848595e2576724ca3e5fbc7442e3e.svg" alt="x_1"/>, while
the first and third integrals should have similar dependence on <img class="math" src="_images/math/b0beda9b652b1ca46a8b6c5c22446ded776ef23c.svg" alt="x_0"/>.
Given these similarities, we would like to do all three integrals simultaneously;
but one integral is two-dimensional and the other two are one-dimensional.</p>
<p>One solution is to turn the one-dimensional integrals into two-dimensional
integrals by rewriting <img class="math" src="_images/math/202d65934be52f25b7eb7d0eb77b6116951a6f5c.svg" alt="I_a^\mathrm{den}"/> as</p>
<div class="math">
<p><img src="_images/math/e8a691cab137e12d70b20fb77688cfda7fa15d0c.svg" alt="I_a^\mathrm{den} &amp;=
\int^{\pi/2}_0 \frac{dx_0}{\pi/2}
\int^{\pi/2}_0 dx_1
\, \mathrm{e}^{-100 \,\mathrm{sin}(x_1)}."/></p>
</div><p>and similarly for <img class="math" src="_images/math/62750d6d8dd5c70d59680f422635963f97a74109.svg" alt="I_b"/>.
These are then easily integrated together —</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">[(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)])</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">rbatchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">Ia_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1e2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="n">Ia_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1e2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Ib</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span>  <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Ia_num</span><span class="o">=</span><span class="n">Ia_num</span><span class="p">,</span> <span class="n">Ia_den</span><span class="o">=</span><span class="n">Ia_den</span><span class="p">,</span> <span class="n">Ib</span><span class="o">=</span><span class="n">Ib</span><span class="p">)</span>

<span class="n">w</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ia =&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Ia_num&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Ia_den&#39;</span><span class="p">],</span> <span class="s1">&#39;Ia - Ib =&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Ia_num&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Ia_den&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Ib&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>— but the result is useless:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.160568</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>    <span class="mf">0.160568</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>        <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.160551</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>    <span class="mf">0.160559</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>        <span class="mf">0.13</span>     <span class="mf">0.94</span>
  <span class="mi">3</span>   <span class="mf">0.160533</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>    <span class="mf">0.160549</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>        <span class="mf">0.36</span>     <span class="mf">0.90</span>
  <span class="mi">4</span>   <span class="mf">0.160568</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>    <span class="mf">0.160555</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>        <span class="mf">0.96</span>     <span class="mf">0.47</span>
  <span class="mi">5</span>   <span class="mf">0.160553</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>    <span class="mf">0.160554</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>        <span class="mf">0.73</span>     <span class="mf">0.72</span>

  <span class="n">key</span><span class="o">/</span><span class="n">index</span>             <span class="n">value</span>
<span class="o">-----------------------------</span>
     <span class="n">Ia_num</span>     <span class="mf">0.160554</span> <span class="p">(</span><span class="mi">15</span><span class="p">)</span>
     <span class="n">Ia_den</span>    <span class="mf">0.0099995</span> <span class="p">(</span><span class="mi">60</span><span class="p">)</span>
         <span class="n">Ib</span>        <span class="mf">14.62</span> <span class="p">(</span><span class="mi">88</span><span class="p">)</span>

<span class="n">Ia</span> <span class="o">=</span> <span class="mf">16.0562</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span> <span class="n">Ia</span> <span class="o">-</span> <span class="n">Ib</span> <span class="o">=</span> <span class="mf">1.43</span><span class="p">(</span><span class="mi">88</span><span class="p">)</span>
</pre></div>
</div>
<p><img class="math" src="_images/math/62750d6d8dd5c70d59680f422635963f97a74109.svg" alt="I_b"/> is almost 100x less accurate than <img class="math" src="_images/math/40ed4aeb446063f687f3a3ad7231a95504f7aa10.svg" alt="I_a"/>, despite
having an integrand with no <code class="docutils literal notranslate"><span class="pre">x[1]</span></code> dependence. The problem is that the
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> map for <code class="docutils literal notranslate"><span class="pre">x[1]</span></code> is tailored to <img class="math" src="_images/math/e6416205c29be213cd4cc575de9ddb0c992ad0ca.svg" alt="I_a^\mathrm{num}"/>, which has
a strong peak at <code class="docutils literal notranslate"><span class="pre">x[1]=0</span></code>. That map is highly sub-optimal for integrating
a function, like that in <img class="math" src="_images/math/62750d6d8dd5c70d59680f422635963f97a74109.svg" alt="I_b"/>, that is independent of <code class="docutils literal notranslate"><span class="pre">x[1]</span></code>.</p>
<p>A much better approach is to rewrite the one-dimensional integrals
as two-dimensional integrals using the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
map’s Jacobian <img class="math" src="_images/math/5ae6a1ac19ddf50143e7ca54148fc9c0576e3c2b.svg" alt="dx_d/dy_d"/> in the extra direction   <img class="math" src="_images/math/76b3e7e49a237eba20ecc53b88ab647d7333530d.svg" alt="d"/>.
For example,</p>
<div class="math">
<p><img src="_images/math/b93914075d7c609f74feb2a3a36eb0642dd5e9ec.svg" alt="I_a^\mathrm{den} &amp;=
\int^{\pi/2}_0 \frac{dx_0}{dx_0/dy_0}
\int^{\pi/2}_0 dx_1
\, \mathrm{e}^{-100 \,\mathrm{sin}(x_1)}."/></p>
</div><p>This turns the <img class="math" src="_images/math/b0beda9b652b1ca46a8b6c5c22446ded776ef23c.svg" alt="x_0"/> integral into an integral over <img class="math" src="_images/math/4314c0d2bea0c6708adeefd9c6c1bb8bb0d54886.svg" alt="0\le y_0 \le 1"/>
with an integrand equal to   1. The Monte Carlo integral over <img class="math" src="_images/math/93b37f0a1c695b1525d5dfef58ebe2c75d4fb1bb.svg" alt="y_0"/>
in <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is then exact; it is unaffected by the map for that direction.
This is easily implemented for both one-dimensional integrals by setting
keyword <code class="docutils literal notranslate"><span class="pre">uses_jac=True</span></code> in the integrator and modifying the integrand:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@vegas</span><span class="o">.</span><span class="n">rbatchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jac</span><span class="p">):</span>
    <span class="n">Ia_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1e2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="n">Ia_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1e2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Ib</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span>  <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">/</span> <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Ia_num</span><span class="o">=</span><span class="n">Ia_num</span><span class="p">,</span> <span class="n">Ia_den</span><span class="o">=</span><span class="n">Ia_den</span><span class="p">,</span> <span class="n">Ib</span><span class="o">=</span><span class="n">Ib</span><span class="p">)</span>

<span class="n">w</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">uses_jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">uses_jac</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Setting <code class="docutils literal notranslate"><span class="pre">uses_jac=True</span></code> causes <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to call the integrand with
two arguments instead of one: <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">jac=jac)</span></code> where <code class="docutils literal notranslate"><span class="pre">jac[d]</span></code> is
the Jacobian for direction   <code class="docutils literal notranslate"><span class="pre">d</span></code> (array <code class="docutils literal notranslate"><span class="pre">jac</span></code> has the same shape
as <code class="docutils literal notranslate"><span class="pre">x</span></code>). This gives much better results —</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.160568</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>    <span class="mf">0.160568</span><span class="p">(</span><span class="mi">44</span><span class="p">)</span>        <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.160551</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>    <span class="mf">0.160560</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>        <span class="mf">0.28</span>     <span class="mf">0.84</span>
  <span class="mi">3</span>   <span class="mf">0.160533</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>    <span class="mf">0.160547</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>        <span class="mf">0.38</span>     <span class="mf">0.89</span>
  <span class="mi">4</span>   <span class="mf">0.160568</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>    <span class="mf">0.160554</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>        <span class="mf">0.58</span>     <span class="mf">0.82</span>
  <span class="mi">5</span>   <span class="mf">0.160553</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>    <span class="mf">0.160553</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>        <span class="mf">0.58</span>     <span class="mf">0.86</span>

  <span class="n">key</span><span class="o">/</span><span class="n">index</span>              <span class="n">value</span>
<span class="o">------------------------------</span>
     <span class="n">Ia_num</span>      <span class="mf">0.160553</span> <span class="p">(</span><span class="mi">15</span><span class="p">)</span>
     <span class="n">Ia_den</span>    <span class="mf">0.01000103</span> <span class="p">(</span><span class="mi">59</span><span class="p">)</span>
         <span class="n">Ib</span>       <span class="mf">15.0749</span> <span class="p">(</span><span class="mi">11</span><span class="p">)</span>

<span class="n">Ia</span> <span class="o">=</span> <span class="mf">16.0536</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="n">Ia</span> <span class="o">-</span> <span class="n">Ib</span> <span class="o">=</span> <span class="mf">0.97868</span><span class="p">(</span><span class="mi">38</span><span class="p">)</span>
</pre></div>
</div>
<p>— where now <img class="math" src="_images/math/40ed4aeb446063f687f3a3ad7231a95504f7aa10.svg" alt="I_a"/> and <img class="math" src="_images/math/62750d6d8dd5c70d59680f422635963f97a74109.svg" alt="I_b"/> are comparable in precision and the difference is
quite accurate. Note that the error on the difference is smaller than either of
the separate errors, because of correlations between the two results.</p>
</section>
<section id="vegas-as-a-random-number-generator">
<h2><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> as a Random Number Generator<a class="headerlink" href="#vegas-as-a-random-number-generator" title="Link to this heading">¶</a></h2>
<p>A <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> integrator generates random points in its integration volume from a
distribution that is optimized for integrals of whatever function it
was trained on. A random sample of integration points and their corresponding weights
can be obtained using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">vegas.Integrator.sample()</span></code>: for example,
the code</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">lbatchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">([(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;integral =&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

<span class="c1"># estimate integral using 5 random sets of integration points</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">wgt</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;lbatch&#39;</span><span class="p">)</span>
    <span class="n">estimates</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">wgt</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;integral =&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">estimates</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;estimates =&#39;</span><span class="p">,</span> <span class="n">estimates</span><span class="p">)</span>
</pre></div>
</div>
<p>gives the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.99982</span><span class="p">(</span><span class="mi">74</span><span class="p">)</span>
<span class="n">integral</span> <span class="o">=</span> <span class="mf">1.0001291624491842</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.9992910111775233</span><span class="p">,</span> <span class="mf">1.0001775493725942</span><span class="p">,</span> <span class="mf">1.0013094938697416</span><span class="p">,</span> <span class="mf">1.0001468331496914</span><span class="p">,</span> <span class="mf">0.9997209246763705</span><span class="p">]</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">d]</span></code> is an array of integration points, and
<code class="docutils literal notranslate"><span class="pre">wgt[i]</span></code> is the array of weights assigned by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to each point so that
<code class="docutils literal notranslate"><span class="pre">sum(wgt</span> <span class="pre">*</span> <span class="pre">f(x))</span></code> (or <code class="docutils literal notranslate"><span class="pre">wgt.dot(f(x))</span></code>) is an estimate of
the integral of (<code class="docutils literal notranslate"><span class="pre">lbatch</span></code>) integrand <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>.</p>
<p>The integrator also
provides low-level access to the random-point generator
through the iterators <a class="reference internal" href="vegas.html#vegas.Integrator.random" title="vegas.Integrator.random"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vegas.Integrator.random()</span></code></a> and
<a class="reference internal" href="vegas.html#vegas.Integrator.random_batch" title="vegas.Integrator.random_batch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vegas.Integrator.random_batch()</span></code></a>.</p>
<p>To illustrate, the following code snippet estimates the integral of function
<code class="docutils literal notranslate"><span class="pre">f(x)</span></code> using integrator <code class="docutils literal notranslate"><span class="pre">integ</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random</span><span class="p">():</span>
    <span class="n">integral</span> <span class="o">+=</span> <span class="n">wgt</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> is a random point in the integration volume and <code class="docutils literal notranslate"><span class="pre">wgt</span></code> is the
weight <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> assigns to that point in an integration. The iterator generates
integration points and weights corresponding to a single iteration of the
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> algorithm. In practice, we would train <code class="docutils literal notranslate"><span class="pre">integ</span></code> on a function whose
shape is similar to that of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> before using it to estimate the integral
of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>.</p>
<p>It is usually more efficient to generate and use integration points in
batches. The <a class="reference internal" href="vegas.html#vegas.Integrator.random_batch" title="vegas.Integrator.random_batch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">vegas.Integrator.random_batch()</span></code></a> iterator does just
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">():</span>
    <span class="n">integral</span> <span class="o">+=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">batch_f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">d]</span></code> is an array of integration points, <code class="docutils literal notranslate"><span class="pre">wgt[i]</span></code> contains the
corresponding weights, and <code class="docutils literal notranslate"><span class="pre">batch_f(x)</span></code> returns an array containing the
corresponding (<code class="docutils literal notranslate"><span class="pre">lbatch</span></code>) integrand values.</p>
<p>The random points generated by <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> are stratified into hypercubes: <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
uses transformed integration variables to improve its Monte Carlo
estimates. It further improves those estimates by subdividing the
integration volume in the transformed variables into a large number of
hypercubes, and doing a Monte Carlo integral in each hypercube separately
(see previous section).
The final result is the sum of the results from all the hypercubes.</p>
<p>To mimic a full <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> integral estimate using the iterators above, we need
to know which points belong to which hypercubes. The following code
shows how this is done, now averaging over <code class="docutils literal notranslate"><span class="pre">nitn</span></code> iterations (equivalent
to what <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> does when <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">variance</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">nitn</span> <span class="o">=</span> <span class="mi">10</span>                                       <span class="c1"># number of iterations</span>
<span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nitn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">wgt_fx</span> <span class="o">=</span> <span class="n">wgt</span> <span class="o">*</span> <span class="n">batch_f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># iterate over hypercubes: compute variance for each,</span>
        <span class="c1">#                          and accumulate for final result</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hcube</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hcube</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">hcube</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>                  <span class="c1"># select array items for h-cube i</span>
            <span class="n">nwf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>                   <span class="c1"># number of points in h-cube i</span>
            <span class="n">wf</span> <span class="o">=</span> <span class="n">wgt_fx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">sum_wf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>         <span class="c1"># sum of wgt * f(x) for h-cube i</span>
            <span class="n">sum_wf2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># sum of (wgt * f(x)) ** 2</span>
            <span class="n">integral</span> <span class="o">+=</span> <span class="n">sum_wf</span>
            <span class="n">variance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sum_wf2</span> <span class="o">*</span> <span class="n">nwf</span> <span class="o">-</span> <span class="n">sum_wf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nwf</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>
<span class="c1"># answer = integral/nitn;   standard deviation = (variance/nitn**2) ** 0.5</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">integral</span> <span class="o">/</span> <span class="n">nitn</span><span class="p">,</span> <span class="p">(</span><span class="n">variance</span> <span class="o">/</span> <span class="n">nitn</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">hcube[i]</span></code> identifies the hypercube containing <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">d]</span></code>. This example is
easily modified to provide information about the <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Jacobian to the integrand, if needed
(see the section <a class="reference internal" href="#vegas-jacobian"><span class="std std-ref">vegas Jacobian</span></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">yield_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">wgt_fx</span> <span class="o">=</span> <span class="n">wgt</span> <span class="o">*</span> <span class="n">batch_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">integ</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">jac1d</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The example is also easily modified for integrands <code class="docutils literal notranslate"><span class="pre">batch_f(xd)</span></code> where <code class="docutils literal notranslate"><span class="pre">xd</span></code>
is a dictionary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">xd</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">(</span><span class="n">integ</span><span class="o">.</span><span class="n">xdict</span><span class="p">,</span> <span class="n">lbatch_buf</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
    <span class="n">wgt_fx</span> <span class="o">=</span> <span class="n">wgt</span> <span class="o">*</span> <span class="n">batch_f</span><span class="p">(</span><span class="n">xd</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">integ.xdict</span></code> provides the template dictionary
used to construct the
dictionary <code class="docutils literal notranslate"><span class="pre">xd</span></code>.</p>
</section>
<section id="implementation-notes">
<h2>Implementation Notes<a class="headerlink" href="#implementation-notes" title="Link to this heading">¶</a></h2>
<p>This implementation relies upon Cython for its speed and
numpy for array processing. It also uses <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code>
for graphics, <code class="xref py py-mod docutils literal notranslate"><span class="pre">h5py</span></code> when <code class="docutils literal notranslate"><span class="pre">minimize_mem=True</span></code>, and
<code class="xref py py-mod docutils literal notranslate"><span class="pre">mpi4py</span></code> for MPI support, but these are all optional.</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> also uses the <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code> module (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">gvar</span></code>).
Integration results are returned as objects of type
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>, which is a class representing Gaussian
random variables (i.e., something with a mean and standard
deviation). These objects can be combined with numbers and
with each other in arbitrary arithmetic expressions to
get new <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s with the correct standard
deviations, and properly correlated with other
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s — that is the tricky part.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Tutorial</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#basic-integrals">Basic Integrals</a></li>
<li><a class="reference internal" href="#multiple-integrands-simultaneously">Multiple Integrands Simultaneously</a></li>
<li><a class="reference internal" href="#dictionaries">Dictionaries</a></li>
<li><a class="reference internal" href="#calculating-distributions">Calculating Distributions</a></li>
<li><a class="reference internal" href="#pdf-integrals">PDF Integrals</a></li>
<li><a class="reference internal" href="#faster-integrands">Faster Integrands</a></li>
<li><a class="reference internal" href="#multiple-processors">Multiple Processors</a></li>
<li><a class="reference internal" href="#sums-with-vegas">Sums with <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a></li>
<li><a class="reference internal" href="#saving-results-automatically">Saving Results Automatically</a></li>
<li><a class="reference internal" href="#vegas-maps-and-preconditioning-vegas"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> Maps and Preconditioning <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a></li>
<li><a class="reference internal" href="#vegas-stratifications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> Stratifications</a></li>
<li><a class="reference internal" href="#vegas-jacobian"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> Jacobian</a></li>
<li><a class="reference internal" href="#vegas-as-a-random-number-generator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> as a Random Number Generator</a></li>
<li><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="index.html"
                          title="previous chapter">vegas Documentation</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="compiled_integrands.html"
                          title="next chapter">Compiled Integrands for Speed; GPUs</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tutorial.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="compiled_integrands.html" title="Compiled Integrands for Speed; GPUs"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="vegas Documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">vegas 6.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tutorial</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2013-2023, G. P. Lepage.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>