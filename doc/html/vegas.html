
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>vegas Module &#8212; vegas 5.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Case Study: Bayesian Curve Fitting" href="outliers.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="outliers.html" title="Case Study: Bayesian Curve Fitting"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">vegas 5.6 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> Module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="vegas-module">
<h1><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Module<a class="headerlink" href="#vegas-module" title="Permalink to this heading">¶</a></h1>
<span class="target" id="module-vegas"></span><section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>The key Python objects supported by the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> module are:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a> — an object describing a multidimensional integration
operator. Such objects contain information about the integration volume,
and also about optimal remappings of the integration variables based
upon the last integral evaluated using the object.</p></li>
<li><p><a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a> — an object describing the remappings used by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvg</span></code></a> — an object describing the result of a <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> integration.
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> returns the weighted average of the integral estimates
from each <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> iteration as an object of class <a class="reference internal" href="#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvg</span></code></a>. These are
Gaussian random variables — that is, they have a
mean and a standard deviation — but also contain information about the
iterations <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> used in generating the result.</p></li>
<li><p><a class="reference internal" href="#vegas.RAvgArray" title="vegas.RAvgArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvgArray</span></code></a> — an array version of <a class="reference internal" href="#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvg</span></code></a> used when
the integrand is array-valued.</p></li>
<li><p><a class="reference internal" href="#vegas.RAvgDict" title="vegas.RAvgDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvgDict</span></code></a> — a dictionary version of <a class="reference internal" href="#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvg</span></code></a> used when
the integrand is dictionary-valued.</p></li>
<li><p><a class="reference internal" href="#vegas.PDFIntegrator" title="vegas.PDFIntegrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFIntegrator</span></code></a> — a specialized integrator for evaluating
Gaussian expectation values.</p></li>
</ul>
</div></blockquote>
<p>These are described in detail below.</p>
</section>
<section id="integrator-objects">
<h2>Integrator Objects<a class="headerlink" href="#integrator-objects" title="Permalink to this heading">¶</a></h2>
<p>The central component of the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> package is the integrator class:</p>
<dl class="py class">
<dt class="sig sig-object py" id="vegas.Integrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">Integrator</span></span><a class="headerlink" href="#vegas.Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive multidimensional Monte Carlo integration.</p>
<p><a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a> objects make Monte Carlo
estimates of multidimensional functions <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>
where <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> is a point in the integration volume:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">integration_region</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>The integator makes <code class="docutils literal notranslate"><span class="pre">nitn</span></code> estimates of the integral,  each
using at most <code class="docutils literal notranslate"><span class="pre">neval</span></code> samples of the integrand, as it adapts to
the specific features of the integrand. Successive estimates (iterations)
typically improve in accuracy until the integrator has fully
adapted. The integrator returns the weighted average of all
<code class="docutils literal notranslate"><span class="pre">nitn</span></code> estimates, together with an estimate of the statistical
(Monte Carlo) uncertainty in that estimate of the integral. The
result is an object of type <a class="reference internal" href="#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">RAvg</span></code></a> (which is derived
from <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>).</p>
<p>Integrands <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> return numbers, arrays of numbers (any shape), or
dictionaries whose values are numbers or arrays (any shape). Each number
returned by an integrand corresponds to a different integrand. When
arrays are returned, <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts to the first number
in the flattened array. When dictionaries are returned,
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts to the first number in the value corresponding to
the first key.</p>
<p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> can generate integration points in batches for integrands
built from classes derived from <a class="reference internal" href="#vegas.BatchIntegrand" title="vegas.BatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.BatchIntegrand</span></code></a>, or
integrand functions decorated by <a class="reference internal" href="#vegas.batchintegrand" title="vegas.batchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.batchintegrand()</span></code></a>. Batch
integrands are typically much faster, especially if they are coded in
Cython or C/C++ or Fortran.</p>
<p><a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a>s have a large number of parameters but the
only ones that most people will care about are: the
number <code class="docutils literal notranslate"><span class="pre">nitn</span></code> of iterations of the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> algorithm;
the maximum number <code class="docutils literal notranslate"><span class="pre">neval</span></code> of integrand evaluations per
iteration; and the damping parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, which is used
to slow down the adaptive algorithms when they would otherwise
be unstable (e.g., with very peaky integrands). Setting parameter
<code class="docutils literal notranslate"><span class="pre">analyzer=vegas.reporter()</span></code> is sometimes useful, as well,
since it causes <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to print (on <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>)
intermediate results from each iteration, as they are
produced. This helps when each iteration takes a long time
to complete (e.g., longer than an hour) because it allows you to
monitor progress as it is being made (or not).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>map</strong> (array, dictionary, <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a> or <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a>) – <p>The integration region  is specified by an array <code class="docutils literal notranslate"><span class="pre">map[d,</span> <span class="pre">i]</span></code>
where <code class="docutils literal notranslate"><span class="pre">d</span></code> is the direction and <code class="docutils literal notranslate"><span class="pre">i=0,1</span></code> specify the lower
and upper limits of integration in direction <code class="docutils literal notranslate"><span class="pre">d</span></code>. Integration
points <code class="docutils literal notranslate"><span class="pre">x</span></code> are packaged as arrays <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> when
passed to the integrand <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>.</p>
<p>Alternatively, the integration region can be specified by a
dictionary whose values <code class="docutils literal notranslate"><span class="pre">map[key]</span></code> are either 2-tuples or
arrays of 2-tuples corresponding to the lower and upper
integration limits for the corresponding variables. Then
integration points <code class="docutils literal notranslate"><span class="pre">xd</span></code> are packaged as dictionaries
having the same structure as <code class="docutils literal notranslate"><span class="pre">map</span></code> but with the integration
limits replaced by the values of the variables:
for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">phi</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)])</span>
</pre></div>
</div>
<p>indicates a three-dimensional integral over variables <code class="docutils literal notranslate"><span class="pre">r</span></code>
(from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>), <code class="docutils literal notranslate"><span class="pre">phi[0]</span></code> (from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">np.pi</span></code>),
and <code class="docutils literal notranslate"><span class="pre">phi[1]</span></code> (from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">2*np.pi</span></code>). In this case
integrands <code class="docutils literal notranslate"><span class="pre">f(xd)</span></code> have dictionary arguments <code class="docutils literal notranslate"><span class="pre">xd</span></code> where
<code class="docutils literal notranslate"><span class="pre">xd['r']</span></code>, <code class="docutils literal notranslate"><span class="pre">xd['phi'][0]</span></code>, and <code class="docutils literal notranslate"><span class="pre">xd['phi'][1]</span></code>
correspond to the integration variables.</p>
<p>Finally <code class="docutils literal notranslate"><span class="pre">map</span></code> could be the integration map from
another <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a>, or that <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a>
itself. In this case the grid is copied from the
existing integrator.</p>
</p></li>
<li><p><strong>xdict</strong> (<em>None</em><em> or </em><em>dictionary</em>) – <p>Setting <code class="docutils literal notranslate"><span class="pre">xdict</span></code>
equal to a dictionary causes integration
variables <code class="docutils literal notranslate"><span class="pre">xd</span></code> to be packaged as
dictionaries, with the same structure as <code class="docutils literal notranslate"><span class="pre">xdict</span></code>,
when passed to the integrand <code class="docutils literal notranslate"><span class="pre">f(xd)</span></code>.
For example, setting</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>indicates that each integration point <code class="docutils literal notranslate"><span class="pre">xd</span></code>
represents three integration variables:
<code class="docutils literal notranslate"><span class="pre">xd['r']</span></code>, <code class="docutils literal notranslate"><span class="pre">xd['phi'][0]</span></code>, and <code class="docutils literal notranslate"><span class="pre">xd['phi'][1]</span></code>.
<code class="docutils literal notranslate"><span class="pre">xdict</span></code> is ignored if set equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default).</p>
</p></li>
<li><p><strong>uses_jac</strong> (<em>bool</em>) – Setting <code class="docutils literal notranslate"><span class="pre">uses_jac=True</span></code> causes <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to
call the integrand with two arguments: <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">jac=jac)</span></code>.
The second argument is the Jacobian <code class="docutils literal notranslate"><span class="pre">jac[d]</span> <span class="pre">=</span> <span class="pre">dx[d]/dy[d]</span></code>
of the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> map. The integral over <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> of <code class="docutils literal notranslate"><span class="pre">1/jac[d]</span></code>
equals 1 (exactly). The default setting
is <code class="docutils literal notranslate"><span class="pre">uses_jac=False</span></code>.</p></li>
<li><p><strong>nitn</strong> (<em>positive int</em>) – The maximum number of iterations used to
adapt to the integrand and estimate its value. The
default value is 10; typical values range from 10
to 20.</p></li>
<li><p><strong>neval</strong> (<em>positive int</em>) – Approximate number of integrand evaluations
in each iteration of the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> algorithm. Increasing
<code class="docutils literal notranslate"><span class="pre">neval</span></code> increases the precision: statistical errors should
fall at least as fast as <code class="docutils literal notranslate"><span class="pre">sqrt(1./neval)</span></code> and often
fall much faster.  The default value is 1000;
real problems often require 10–10,000 times more evaluations
than this.</p></li>
<li><p><strong>nstrat</strong> (<em>int array</em>) – <code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> specifies the number of
stratifications to use in direction <code class="docutils literal notranslate"><span class="pre">d</span></code>. By default this
parameter is set automatically, based on parameter <code class="docutils literal notranslate"><span class="pre">neval</span></code>,
with <code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> approximately the same for every <code class="docutils literal notranslate"><span class="pre">d</span></code>.
Specifying <code class="docutils literal notranslate"><span class="pre">nstrat</span></code> explicitly makes it possible to
concentrate stratifications in directions  where they are most
needed. If <code class="docutils literal notranslate"><span class="pre">nstrat</span></code> is set but <code class="docutils literal notranslate"><span class="pre">neval</span></code> is not,
<code class="docutils literal notranslate"><span class="pre">neval</span></code> is set equal to <code class="docutils literal notranslate"><span class="pre">2*prod(nstrat)/(1-neval_frac)</span></code>.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Damping parameter controlling the remapping
of the integration variables as <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts to the
integrand. Smaller values slow adaptation, which may be
desirable for difficult integrands. Small or zero <code class="docutils literal notranslate"><span class="pre">alpha</span></code>s
are also sometimes useful after the grid has adapted,
to minimize fluctuations away from the optimal grid.
The default value is 0.5.</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – Damping parameter controlling the redistribution
of integrand evaluations across hypercubes in the
stratified sampling of the integral (over transformed
variables). Smaller values limit the amount of
redistribution. The theoretically optimal value is 1;
setting <code class="docutils literal notranslate"><span class="pre">beta=0</span></code> prevents any redistribution of
evaluations. The default value is 0.75.</p></li>
<li><p><strong>neval_frac</strong> (<em>float</em>) – Approximate fraction of function evaluations
used for adaptive stratified sampling. <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
distributes <code class="docutils literal notranslate"><span class="pre">(1-neval_frac)*neval</span></code>  integrand evaluations
uniformly over all hypercubes, with at  least 2 evaluations
per hypercube. The remaining <code class="docutils literal notranslate"><span class="pre">neval_frac*neval</span></code>
evaluations are concentrated in hypercubes where the errors
are largest. Increasing <code class="docutils literal notranslate"><span class="pre">neval_frac</span></code> makes more integrand
evaluations available for adaptive stratified
sampling, but reduces the number of hypercubes, which limits
the algorithm’s ability to adapt. Ignored when <code class="docutils literal notranslate"><span class="pre">beta=0</span></code>.
Default is <code class="docutils literal notranslate"><span class="pre">neval_frac=0.75</span></code>.</p></li>
<li><p><strong>adapt</strong> (<em>bool</em>) – Setting <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code> prevents further
adaptation by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>. Typically this would be done
after training the <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a> on an integrand, in order
to stabilize further estimates of the integral. <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> uses
unweighted averages to combine results from different
iterations when <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code>. The default setting
is <code class="docutils literal notranslate"><span class="pre">adapt=True</span></code>.</p></li>
<li><p><strong>nproc</strong> (<em>int</em><em> or </em><em>None</em>) – <p>Number of processes/processors used
to evalute the integrand. If <code class="docutils literal notranslate"><span class="pre">nproc&gt;1</span></code> Python’s
<code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> module is used to spread
integration points across multiple processors, thereby
potentially reducing the time required to evaluate the
integral. There is a significant overhead involved in using
multiple processors so this option is useful only when
the integrand is expensive to evaluate. When using the
<code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> module in its default mode for
MacOS and Windows, it is important that the main module
can be safely imported (i.e., without launching new
processes). This can be accomplished with
some version of the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__`:</span></code>
construct in the main module: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>This is not an issue on other Unix platforms.
See the <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> documentation
for more information. Note that setting <code class="docutils literal notranslate"><span class="pre">nproc</span></code>
greater than 1 disables MPI support.
Set <code class="docutils literal notranslate"><span class="pre">nproc=None</span></code> to use all the processors
on the machine (equivalent to <code class="docutils literal notranslate"><span class="pre">nproc=os.cpu_count()</span></code>).
Default value is <code class="docutils literal notranslate"><span class="pre">nproc=1</span></code>. (Requires Python 3.3 or later.)</p>
</p></li>
<li><p><strong>analyzer</strong> – <p>An object with methods</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">analyzer.begin(itn,</span> <span class="pre">integrator)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">analyzer.end(itn_result,</span> <span class="pre">result)</span></code></p>
</div></blockquote>
<p>where: <code class="docutils literal notranslate"><span class="pre">begin(itn,</span> <span class="pre">integrator)</span></code> is called at the start
of each <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> iteration with <code class="docutils literal notranslate"><span class="pre">itn</span></code> equal to the
iteration number and <code class="docutils literal notranslate"><span class="pre">integrator</span></code> equal to the
integrator itself; and <code class="docutils literal notranslate"><span class="pre">end(itn_result,</span> <span class="pre">result)</span></code>
is called at the end of each iteration with
<code class="docutils literal notranslate"><span class="pre">itn_result</span></code> equal to the result for that
iteration and <code class="docutils literal notranslate"><span class="pre">result</span></code> equal to the cummulative
result of all iterations so far.
Setting <code class="docutils literal notranslate"><span class="pre">analyzer=vegas.reporter()</span></code>, for
example, causes vegas to print out a running report
of its results as they are produced. The default
is <code class="docutils literal notranslate"><span class="pre">analyzer=None</span></code>.</p>
</p></li>
<li><p><strong>min_neval_batch</strong> (<em>positive int</em>) – The minimum number of integration
points to be passed together to the integrand when using
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> in batch mode. The default value is 50,000. Larger
values may be lead to faster evaluations, but at the cost of
more memory for internal work arrays. The last batch is
usually smaller than this limit, as it is limited by <code class="docutils literal notranslate"><span class="pre">neval</span></code>.</p></li>
<li><p><strong>max_neval_hcube</strong> (<em>positive int</em>) – Maximum number of integrand
evaluations per hypercube in the stratification. The default
value is 50,000. Larger values might allow for more adaptation
(when <code class="docutils literal notranslate"><span class="pre">beta&gt;0</span></code>), but also allow for more over-shoot when
adapting to sharp peaks. Larger values also can result in
large internal work arrasy.</p></li>
<li><p><strong>minimize_mem</strong> (<em>bool</em>) – When <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> minimizes
internal workspace by moving some of its data to
a disk file. This increases execution time (slightly)
and results in temporary files, but might be desirable
when the number of evaluations is very large (e.g.,
<code class="docutils literal notranslate"><span class="pre">neval=1e9</span></code>).  <code class="docutils literal notranslate"><span class="pre">minimize_mem=True</span></code>
requires the <code class="docutils literal notranslate"><span class="pre">h5py</span></code> Python module.</p></li>
<li><p><strong>max_mem</strong> (<em>positive float</em>) – Maximum number of floats allowed in
internal work arrays (approx.). A <code class="docutils literal notranslate"><span class="pre">MemoryError</span></code> is
raised if the work arrays are too large, in which case
one might want to reduce <code class="docutils literal notranslate"><span class="pre">min_neval_batch</span></code> or
<code class="docutils literal notranslate"><span class="pre">max_neval_hcube</span></code>, or set <code class="docutils literal notranslate"><span class="pre">minimize_mem=True</span></code>
(or increase <code class="docutils literal notranslate"><span class="pre">max_mem</span></code> if there is enough RAM).
Default value is 1e9.</p></li>
<li><p><strong>maxinc_axis</strong> (<em>positive int</em>) – The maximum number of increments
per axis allowed for the x-space grid. The default
value is 1000; there is probably little need to use
other values.</p></li>
<li><p><strong>rtol</strong> (<em>float</em>) – Relative error in the integral estimate
at which point the integrator can stop. The default
value is 0.0 which turns off this stopping condition.
This stopping condition can be quite unreliable
in early iterations, before <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> has converged.
Use with caution, if at all.</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – Absolute error in the integral estimate
at which point the integrator can stop. The default
value is 0.0 which turns off this stopping condition.
This stopping condition can be quite unreliable
in early iterations, before <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> has converged.
Use with caution, if at all.</p></li>
<li><p><strong>ran_array_generator</strong> – Replacement function for the default
random number generator. <code class="docutils literal notranslate"><span class="pre">ran_array_generator(size)</span></code>
should create random numbers uniformly distributed
between 0 and 1 in an array whose dimensions are specified by the
integer-valued tuple <code class="docutils literal notranslate"><span class="pre">size</span></code>. Setting <code class="docutils literal notranslate"><span class="pre">ran_array_generator</span></code>
to <code class="docutils literal notranslate"><span class="pre">None</span></code> restores the default generator (from <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code>).</p></li>
<li><p><strong>sync_ran</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), the <em>default</em> random
number generator is synchronized across all processors when
using MPI. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> does no synchronization
(but the random numbers should synchronized some other
way). Ignored if not using MPI.</p></li>
<li><p><strong>adapt_to_errors</strong> (<em>bool</em>) – <p><code class="docutils literal notranslate"><span class="pre">adapt_to_errors=False</span></code> causes <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to remap the
integration variables to emphasize regions where <code class="docutils literal notranslate"><span class="pre">|f(x)|</span></code>
is largest. This is the default mode.</p>
<p><code class="docutils literal notranslate"><span class="pre">adapt_to_errors=True</span></code> causes <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to remap
variables to emphasize regions where the Monte Carlo
error is largest. This might be superior when
the number of the number of stratifications (<code class="docutils literal notranslate"><span class="pre">self.nstrat</span></code>)
in the y grid is large (&gt; 100). It is typically
useful only in one or two dimensions.</p>
</p></li>
<li><p><strong>uniform_nstrat</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, requires that the
<code class="docutils literal notranslate"><span class="pre">nstrat[d]</span></code> be equal for all <code class="docutils literal notranslate"><span class="pre">d</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default),
the algorithm maximizes the number of stratifications while
requiring <code class="docutils literal notranslate"><span class="pre">|nstrat[d1]</span> <span class="pre">-</span> <span class="pre">nstrat[d2]|</span> <span class="pre">&lt;=</span> <span class="pre">1</span></code>. This parameter
is ignored if <code class="docutils literal notranslate"><span class="pre">nstrat</span></code> is specified explicitly.</p></li>
<li><p><strong>mpi</strong> – Setting <code class="docutils literal notranslate"><span class="pre">mpi=False</span></code> disables <code class="docutils literal notranslate"><span class="pre">mpi</span></code> support in
<code class="docutils literal notranslate"><span class="pre">vegas</span></code> even if <code class="docutils literal notranslate"><span class="pre">mpi</span></code> is available; setting <code class="docutils literal notranslate"><span class="pre">mpi=True</span></code>
(default) allows use of <code class="docutils literal notranslate"><span class="pre">mpi</span></code> provided module <code class="xref py py-mod docutils literal notranslate"><span class="pre">mpi4py</span></code>
is installed. This flag is ignored when <code class="docutils literal notranslate"><span class="pre">mpi</span></code> is not
being used (and so has no impact on performance).</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Methods:</dt><dd><dl class="py method">
<dt class="sig sig-object py" id="vegas.Integrator.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fcn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveall</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.Integrator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate integrand <code class="docutils literal notranslate"><span class="pre">fcn</span></code>.</p>
<p>A typical integrand has the form, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">4</span>
</pre></div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> is an integration point, where
index <code class="docutils literal notranslate"><span class="pre">d=0...</span></code> represents direction within the
integration volume.</p>
<p>Integrands can be array-valued, representing multiple
integrands: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The return arrays can have any shape. Dictionary-valued
integrands are also supported: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Integrand functions that return arrays or dictionaries
are useful for multiple integrands that are closely related,
and can lead to substantial reductions in the errors for
ratios or differences of the results.</p>
<p>Integrand’s take dictionaries as arguments when
<a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator</span></code></a> keyword <code class="docutils literal notranslate"><span class="pre">map</span></code> (or <code class="docutils literal notranslate"><span class="pre">xdict</span></code>) is
set equal to a dictionary. For example, with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">theta</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">phi</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
</pre></div>
</div>
<p>the volume of a unit sphere is obtained by integrating</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">xd</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>It is usually much faster to use <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> in batch
mode, where integration points are presented to the
integrand in batches. A simple batch integrand might
be, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@vegas</span><span class="o">.</span><span class="n">batchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">4</span>
</pre></div>
</div>
<p>where decorator <code class="docutils literal notranslate"><span class="pre">&#64;vegas.batchintegrand</span></code> tells
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> that the integrand processes integration
points in batches. The array <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">d]</span></code>
represents a collection of different integration
points labeled by <code class="docutils literal notranslate"><span class="pre">i=0...</span></code>. (The number of points is controlled
<a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a> parameter <code class="docutils literal notranslate"><span class="pre">min_neval_batch</span></code>.) The batch index
is always first.</p>
<p>Batch integrands can also be constructed from classes
derived from <a class="reference internal" href="#vegas.BatchIntegrand" title="vegas.BatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.BatchIntegrand</span></code></a>.</p>
<p>Batch mode is particularly useful (and fast) when the class
derived from <a class="reference internal" href="#vegas.BatchIntegrand" title="vegas.BatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.BatchIntegrand</span></code></a> is coded
in Cython. Then loops over the integration points
can be coded explicitly, avoiding the need to use
<code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code>’s whole-array operators if they are not
well suited to the integrand.</p>
<p>Any <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> parameter can also be reset: e.g.,
<code class="docutils literal notranslate"><span class="pre">self(fcn,</span> <span class="pre">nitn=20,</span> <span class="pre">neval=1e6)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fcn</strong> (<em>callable</em>) – Integrand function.</p></li>
<li><p><strong>save</strong> (<em>str</em><em> or </em><em>file</em><em> or </em><em>None</em>) – <p>Writes <code class="docutils literal notranslate"><span class="pre">results</span></code> into pickle file specified
by <code class="docutils literal notranslate"><span class="pre">save</span></code> at the end of each iteration. For example, setting
<code class="docutils literal notranslate"><span class="pre">save='results.pkl'</span></code> means that the results returned by the last
vegas iteration can be reconstructed later using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
</pre></div>
</div>
<p>Ignored if <code class="docutils literal notranslate"><span class="pre">save=None</span></code> (default).</p>
</p></li>
<li><p><strong>saveall</strong> (<em>str</em><em> or </em><em>file</em><em> or </em><em>None</em>) – <p>Writes <code class="docutils literal notranslate"><span class="pre">(results,</span> <span class="pre">integrator)</span></code> into pickle
file specified by <code class="docutils literal notranslate"><span class="pre">saveall</span></code> at the end of each iteration. For example,
setting <code class="docutils literal notranslate"><span class="pre">saveall='allresults.pkl'</span></code> means that the results returned by
the last vegas iteration, together with a clone of the (adapted) integrator,
can be reconstructed later using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;allresults.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
    <span class="n">results</span><span class="p">,</span> <span class="n">integrator</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
</pre></div>
</div>
<p>Ignored if <code class="docutils literal notranslate"><span class="pre">saveall=None</span></code> (default).</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.Integrator.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ka</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.Integrator.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset default parameters in integrator.</p>
<p>Usage is analogous to the constructor
for <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a>: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">old_defaults</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">neval</span><span class="o">=</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>resets the default values for <code class="docutils literal notranslate"><span class="pre">neval</span></code> and <code class="docutils literal notranslate"><span class="pre">nitn</span></code>
in <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a> <code class="docutils literal notranslate"><span class="pre">integ</span></code>. A dictionary, here
<code class="docutils literal notranslate"><span class="pre">old_defaults</span></code>, is returned. It can be used
to restore the old defaults using, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integ</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">old_defaults</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.Integrator.settings">
<span class="sig-name descname"><span class="pre">settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ngrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.Integrator.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble summary of integrator settings into string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ngrid</strong> (<em>int</em>) – Number of grid nodes in each direction
to include in summary.
The default is 0.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>String containing the settings.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.Integrator.random">
<span class="sig-name descname"><span class="pre">random</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yield_hcube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yield_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.Integrator.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over integration points and weights.</p>
<p>This method creates an iterator that returns integration
points from <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>, and their corresponding weights in an
integral. Each point <code class="docutils literal notranslate"><span class="pre">x[d]</span></code> is accompanied by the weight
assigned to that point by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> when estimating an integral.
Optionally it will also return the index of the hypercube
containing the integration point and/or the y-space
coordinates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integ</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>  <span class="n">yields</span>  <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span>

<span class="n">integ</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="n">yields</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span>

<span class="n">integ</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">yield_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="n">yields</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">wgt</span>

<span class="n">integ</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">yield_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="n">yields</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span>
</pre></div>
</div>
<p>The number of integration points returned by the iterator
corresponds to a single iteration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.Integrator.random_batch">
<span class="sig-name descname"><span class="pre">random_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yield_hcube</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yield_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.Integrator.random_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over integration points and weights.</p>
<p>This method creates an iterator that returns integration
points from <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>, and their corresponding weights in an
integral. The points are provided in arrays <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">d]</span></code> where
<code class="docutils literal notranslate"><span class="pre">i=0...</span></code> labels the integration points in a batch
and <code class="docutils literal notranslate"><span class="pre">d=0...</span></code> labels direction. The corresponding
weights assigned by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to each point are provided
in an array <code class="docutils literal notranslate"><span class="pre">wgt[i]</span></code>.</p>
<p>Optionally the integrator will also return the indices of
the hypercubes containing the integration points and/or the y-space
coordinates of those points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">()</span>  <span class="n">yields</span>  <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span>

<span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="n">yields</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span>

<span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">(</span><span class="n">yield_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="n">yields</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">wgt</span>

<span class="n">integ</span><span class="o">.</span><span class="n">random_batch</span><span class="p">(</span><span class="n">yield_hcube</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">yield_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="n">yields</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span> <span class="n">hcube</span>
</pre></div>
</div>
<p>The number of integration points returned by the iterator
corresponds to a single iteration. The number in a batch
is controlled by parameter <code class="docutils literal notranslate"><span class="pre">nhcube_batch</span></code>.</p>
</dd></dl>

</dd>
</dl>
</dd></dl>

</section>
<section id="adaptivemap-objects">
<h2>AdaptiveMap Objects<a class="headerlink" href="#adaptivemap-objects" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s remapping of the integration variables is handled
by a <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a> object, which maps the original
integration variables x into new variables y in a unit hypercube.
Each direction has its own map specified by a grid in x space:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/530e5cb1976f764189866fce2e85424d78e6d201.svg" alt="x_0 &amp;= a \\
x_1 &amp;= x_0 + \Delta x_0 \\
x_2 &amp;= x_1 + \Delta x_1 \\
\cdots \\
x_N &amp;= x_{N-1} + \Delta x_{N-1} = b"/></p>
</div></div></blockquote>
<p>where <img class="math" src="_images/math/34934efedf7cb6cf31f0333b486c4ab43e90855d.svg" alt="a"/> and <img class="math" src="_images/math/5cf70d30bed668864d41ac882237465737e7f20f.svg" alt="b"/> are the limits of integration.
The grid specifies the transformation function at the points
<img class="math" src="_images/math/4011b7a530d6ec1b95ffad04de4ed07502a3f8b0.svg" alt="y=i/N"/> for <img class="math" src="_images/math/dda86e9e64f520a61e58012f9e1638c0a93fa1a6.svg" alt="i=0,1\ldots N"/>:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/1ad1f2a16147f5fee5b6ccdbe551bc9512841c6f.svg" alt="x(y\!=\!i/N) = x_i"/></p>
</div></div></blockquote>
<p>Linear interpolation is used between those points. The Jacobian
for this transformation is:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/43b71c97d41ce6b26dd55bb3f1538e17839a09e3.svg" alt="J(y) = J_i = N \Delta x_i"/></p>
</div></div></blockquote>
<p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adjusts the increments sizes to optimize its Monte Carlo
estimates of the integral. This involves training the grid. To
illustrate how this is done with <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a>s consider a simple
two dimensional integral over a unit hypercube with integrand:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
<p>We want to create a grid that optimizes uniform Monte Carlo estimates
of the integral in y space. We do this by sampling the integrand
at a large number <code class="docutils literal notranslate"><span class="pre">ny</span></code> of random points <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code>, where <code class="docutils literal notranslate"><span class="pre">j=0...ny-1</span></code>
and <code class="docutils literal notranslate"><span class="pre">d=0,1</span></code>, uniformly distributed throughout the integration
volume in y space. These samples be used to train the grid
using the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">AdaptiveMap</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">ninc</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">ny</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># 1000 random y&#39;s</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>            <span class="c1"># work space</span>
<span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;intial grid:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">settings</span><span class="p">())</span>

<span class="k">for</span> <span class="n">itn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>                    <span class="c1"># 5 iterations to adapt</span>
   <span class="n">m</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">jac</span><span class="p">)</span>                     <span class="c1"># compute x&#39;s and jac</span>

   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>                  <span class="c1"># compute training data</span>
      <span class="n">f2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">jac</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">**</span> <span class="mi">2</span>

   <span class="n">m</span><span class="o">.</span><span class="n">add_training_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>           <span class="c1"># adapt</span>
   <span class="n">m</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;iteration </span><span class="si">%d</span><span class="s1">:&#39;</span> <span class="o">%</span> <span class="n">itn</span><span class="p">)</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">settings</span><span class="p">())</span>
</pre></div>
</div>
<p>In each of the 5 iterations, the <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a> adjusts the
map, making increments smaller where <code class="docutils literal notranslate"><span class="pre">f2</span></code> is larger and
larger where <code class="docutils literal notranslate"><span class="pre">f2</span></code> is smaller.
The map converges after only 2 or 3 iterations, as
is clear from the output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initial</span> <span class="n">grid</span><span class="p">:</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>   <span class="mf">0.2</span>  <span class="mf">0.4</span>  <span class="mf">0.6</span>  <span class="mf">0.8</span>  <span class="mf">1.</span> <span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>   <span class="mf">0.2</span>  <span class="mf">0.4</span>  <span class="mf">0.6</span>  <span class="mf">0.8</span>  <span class="mf">1.</span> <span class="p">]</span>

<span class="n">iteration</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.412</span>  <span class="mf">0.62</span>   <span class="mf">0.76</span>   <span class="mf">0.883</span>  <span class="mf">1.</span>   <span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.506</span>  <span class="mf">0.691</span>  <span class="mf">0.821</span>  <span class="mf">0.91</span>   <span class="mf">1.</span>   <span class="p">]</span>

<span class="n">iteration</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.428</span>  <span class="mf">0.63</span>   <span class="mf">0.772</span>  <span class="mf">0.893</span>  <span class="mf">1.</span>   <span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.531</span>  <span class="mf">0.713</span>  <span class="mf">0.832</span>  <span class="mf">0.921</span>  <span class="mf">1.</span>   <span class="p">]</span>

<span class="n">iteration</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.433</span>  <span class="mf">0.63</span>   <span class="mf">0.772</span>  <span class="mf">0.894</span>  <span class="mf">1.</span>   <span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.533</span>  <span class="mf">0.714</span>  <span class="mf">0.831</span>  <span class="mf">0.922</span>  <span class="mf">1.</span>   <span class="p">]</span>

<span class="n">iteration</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.435</span>  <span class="mf">0.631</span>  <span class="mf">0.772</span>  <span class="mf">0.894</span>  <span class="mf">1.</span>   <span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.533</span>  <span class="mf">0.715</span>  <span class="mf">0.831</span>  <span class="mf">0.923</span>  <span class="mf">1.</span>   <span class="p">]</span>

<span class="n">iteration</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.436</span>  <span class="mf">0.631</span>  <span class="mf">0.772</span>  <span class="mf">0.895</span>  <span class="mf">1.</span>   <span class="p">]</span>
    <span class="n">grid</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.533</span>  <span class="mf">0.715</span>  <span class="mf">0.831</span>  <span class="mf">0.924</span>  <span class="mf">1.</span>   <span class="p">]</span>

</pre></div>
</div>
<p>The grid increments along direction 0 shrink at larger
values <code class="docutils literal notranslate"><span class="pre">x[0]</span></code>,  varying as <code class="docutils literal notranslate"><span class="pre">1/x[0]</span></code>. Along direction 1
the increments shrink more quickly varying like <code class="docutils literal notranslate"><span class="pre">1/x[1]**2</span></code>.</p>
<p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> samples the integrand in order to estimate the integral.
It uses those same samples to train its <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.AdaptiveMap</span></code></a> in this
fashion, for use in subsequent iterations of the algorithm.</p>
<dl class="py class">
<dt class="sig sig-object py" id="vegas.AdaptiveMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">AdaptiveMap</span></span><a class="headerlink" href="#vegas.AdaptiveMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive map <code class="docutils literal notranslate"><span class="pre">y-&gt;x(y)</span></code> for multidimensional <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>An <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaptiveMap</span></code></a> defines a multidimensional map <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x(y)</span></code>
from the unit hypercube, with <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">y[d]</span> <span class="pre">&lt;=</span> <span class="pre">1</span></code>, to an arbitrary
hypercube in <code class="docutils literal notranslate"><span class="pre">x</span></code> space. Each direction is mapped independently
with a Jacobian that is tunable (i.e., “adaptive”).</p>
<p>The map is specified by a grid in <code class="docutils literal notranslate"><span class="pre">x</span></code>-space that, by definition,
maps into a uniformly spaced grid in <code class="docutils literal notranslate"><span class="pre">y</span></code>-space. The nodes of
the grid are specified by <code class="docutils literal notranslate"><span class="pre">grid[d,</span> <span class="pre">i]</span></code> where d is the
direction (<code class="docutils literal notranslate"><span class="pre">d=0,1...dim-1</span></code>) and <code class="docutils literal notranslate"><span class="pre">i</span></code> labels the grid point
(<code class="docutils literal notranslate"><span class="pre">i=0,1...N</span></code>). The mapping for a specific point <code class="docutils literal notranslate"><span class="pre">y</span></code> into
<code class="docutils literal notranslate"><span class="pre">x</span></code> space is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">d</span><span class="p">])]</span> <span class="o">+</span> <span class="n">inc</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">d</span><span class="p">])]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">i(y)=floor(y*N</span></code>), <code class="docutils literal notranslate"><span class="pre">delta(y)=y*N</span> <span class="pre">-</span> <span class="pre">i(y)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">inc[d,</span> <span class="pre">i]</span> <span class="pre">=</span> <span class="pre">grid[d,</span> <span class="pre">i+1]</span> <span class="pre">-</span> <span class="pre">grid[d,</span> <span class="pre">i]</span></code>. The Jacobian for this map,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dx</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">/</span><span class="n">dy</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">inc</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">d</span><span class="p">])]</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span>
</pre></div>
</div>
<p>is piece-wise constant and proportional to the <code class="docutils literal notranslate"><span class="pre">x</span></code>-space grid
spacing. Each increment in the <code class="docutils literal notranslate"><span class="pre">x</span></code>-space grid maps into an increment of
size <code class="docutils literal notranslate"><span class="pre">1/N</span></code> in the corresponding <code class="docutils literal notranslate"><span class="pre">y</span></code> space. So regions in
<code class="docutils literal notranslate"><span class="pre">x</span></code> space where <code class="docutils literal notranslate"><span class="pre">inc[d,</span> <span class="pre">i]</span></code> is small are stretched out
in <code class="docutils literal notranslate"><span class="pre">y</span></code> space, while larger increments are compressed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">x</span></code> grid for an <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaptiveMap</span></code></a> can be specified explicitly
when the map is created: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">AdaptiveMap</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>creates a two-dimensional map where the <code class="docutils literal notranslate"><span class="pre">x[0]</span></code> interval <code class="docutils literal notranslate"><span class="pre">(0,0.1)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(0.1,1)</span></code> map into the <code class="docutils literal notranslate"><span class="pre">y[0]</span></code> intervals <code class="docutils literal notranslate"><span class="pre">(0,0.5)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(0.5,1)</span></code> respectively, while <code class="docutils literal notranslate"><span class="pre">x[1]</span></code> intervals <code class="docutils literal notranslate"><span class="pre">(-1,0)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(0,1)</span></code> map into <code class="docutils literal notranslate"><span class="pre">y[1]</span></code> intervals <code class="docutils literal notranslate"><span class="pre">(0,0.5)</span></code> and  <code class="docutils literal notranslate"><span class="pre">(0.5,1)</span></code>.</p>
<p>More typically, an uniform map with <code class="docutils literal notranslate"><span class="pre">ninc</span></code> increments
is first created: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">AdaptiveMap</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">ninc</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>creates a two-dimensional grid, with 1000 increments in each direction,
that spans the volume <code class="docutils literal notranslate"><span class="pre">0&lt;=x[0]&lt;=1</span></code>, <code class="docutils literal notranslate"><span class="pre">-1&lt;=x[1]&lt;=1</span></code>. This map is then
trained with data <code class="docutils literal notranslate"><span class="pre">f[j]</span></code> corresponding to <code class="docutils literal notranslate"><span class="pre">ny</span></code> points <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code>,
with <code class="docutils literal notranslate"><span class="pre">j=0...ny-1</span></code>, (usually) uniformly distributed in y space:
for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">add_training_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">m.adapt(alpha=1.5)</span></code> shrinks grid increments where <code class="docutils literal notranslate"><span class="pre">f[j]</span></code>
is large, and expands them where <code class="docutils literal notranslate"><span class="pre">f[j]</span></code> is small. Usually
one has to iterate over several sets of <code class="docutils literal notranslate"><span class="pre">y</span></code>s and <code class="docutils literal notranslate"><span class="pre">f</span></code>s
before the grid has fully adapted.</p>
<p>The speed with which the grid adapts is determined by parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>.
Large (positive) values imply rapid adaptation, while small values (much
less than one) imply slow adaptation. As in any iterative process that
involves random numbers, it is  usually a good idea to slow adaptation
down in order to avoid instabilities caused by random fluctuations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<em>list of arrays</em>) – Initial <code class="docutils literal notranslate"><span class="pre">x</span></code> grid, where <code class="docutils literal notranslate"><span class="pre">grid[d][i]</span></code>
is the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th node in direction <code class="docutils literal notranslate"><span class="pre">d</span></code>. Different directions
can have different numbers of nodes.</p></li>
<li><p><strong>ninc</strong> (int or array or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – <code class="docutils literal notranslate"><span class="pre">ninc[d]</span></code> (or <code class="docutils literal notranslate"><span class="pre">ninc</span></code>, if it
is a number) is the number of increments along direction <code class="docutils literal notranslate"><span class="pre">d</span></code>
in the new  <code class="docutils literal notranslate"><span class="pre">x</span></code> grid. The new grid is designed to give the same
Jacobian <code class="docutils literal notranslate"><span class="pre">dx(y)/dy</span></code> as the original grid. The default value,
<code class="docutils literal notranslate"><span class="pre">ninc=None</span></code>, leaves the grid unchanged.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Attributes and methods:</dt><dd><dl class="py attribute">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.dim">
<span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#vegas.AdaptiveMap.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dimensions.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.ninc">
<span class="sig-name descname"><span class="pre">ninc</span></span><a class="headerlink" href="#vegas.AdaptiveMap.ninc" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">ninc[d]</span></code> is the number increments in direction <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.grid">
<span class="sig-name descname"><span class="pre">grid</span></span><a class="headerlink" href="#vegas.AdaptiveMap.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>The nodes of the grid defining the maps are <code class="docutils literal notranslate"><span class="pre">self.grid[d,</span> <span class="pre">i]</span></code>
where <code class="docutils literal notranslate"><span class="pre">d=0...</span></code> specifies the direction and <code class="docutils literal notranslate"><span class="pre">i=0...self.ninc</span></code>
the node.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.inc">
<span class="sig-name descname"><span class="pre">inc</span></span><a class="headerlink" href="#vegas.AdaptiveMap.inc" title="Permalink to this definition">¶</a></dt>
<dd><p>The increment widths of the grid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">inc</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.adapt">
<span class="sig-name descname"><span class="pre">adapt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ninc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapt grid to accumulated training data.</p>
<p><code class="docutils literal notranslate"><span class="pre">self.adapt(...)</span></code> projects the training data onto
each axis independently and maps it into <code class="docutils literal notranslate"><span class="pre">x</span></code> space.
It shrinks <code class="docutils literal notranslate"><span class="pre">x</span></code>-grid increments in regions where the
projected training data is large, and grows increments
where the projected data is small. The grid along
any direction is unchanged if the training data
is constant along that direction.</p>
<p>The number of increments along a direction can be
changed by setting parameter <code class="docutils literal notranslate"><span class="pre">ninc</span></code> (array or number).</p>
<p>The grid does not change if no training data has
been accumulated, unless <code class="docutils literal notranslate"><span class="pre">ninc</span></code> is specified, in
which case the number of increments is adjusted
while preserving the relative density of increments
at different values of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>double</em>) – Determines the speed with which the grid
adapts to training data. Large (postive) values imply
rapid evolution; small values (much less than one) imply
slow evolution. Typical values are of order one. Choosing
<code class="docutils literal notranslate"><span class="pre">alpha&lt;0</span></code> causes adaptation to the unmodified training
data (usually not a good idea).</p></li>
<li><p><strong>ninc</strong> (<em>int</em><em> or </em><em>array</em><em> or </em><em>None</em>) – The number of increments in the new
grid is <code class="docutils literal notranslate"><span class="pre">ninc[d]</span></code> (or <code class="docutils literal notranslate"><span class="pre">ninc</span></code>, if it is a number)
in direction <code class="docutils literal notranslate"><span class="pre">d</span></code>. The number is unchanged from the
old grid if <code class="docutils literal notranslate"><span class="pre">ninc</span></code> is omitted (or equals <code class="docutils literal notranslate"><span class="pre">None</span></code>,
which is the default).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.add_training_data">
<span class="sig-name descname"><span class="pre">add_training_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.add_training_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add training data <code class="docutils literal notranslate"><span class="pre">f</span></code> for <code class="docutils literal notranslate"><span class="pre">y</span></code>-space points <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>Accumulates training data for later use by <code class="docutils literal notranslate"><span class="pre">self.adapt()</span></code>.
Grid increments will be made smaller in regions where
<code class="docutils literal notranslate"><span class="pre">f</span></code> is larger than average, and larger where <code class="docutils literal notranslate"><span class="pre">f</span></code>
is smaller than average. The grid is unchanged (converged?)
when <code class="docutils literal notranslate"><span class="pre">f</span></code> is constant across the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>array</em>) – <code class="docutils literal notranslate"><span class="pre">y</span></code> values corresponding to the training data.
<code class="docutils literal notranslate"><span class="pre">y</span></code> is a contiguous 2-d array, where <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code>
is for points along direction <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p></li>
<li><p><strong>f</strong> (<em>array</em>) – Training function values. <code class="docutils literal notranslate"><span class="pre">f[j]</span></code> corresponds to
point <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code> in <code class="docutils literal notranslate"><span class="pre">y</span></code>-space.</p></li>
<li><p><strong>ny</strong> (<em>int</em>) – Number of <code class="docutils literal notranslate"><span class="pre">y</span></code> points: <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code> for <code class="docutils literal notranslate"><span class="pre">d=0...dim-1</span></code>
and <code class="docutils literal notranslate"><span class="pre">j=0...ny-1</span></code>. <code class="docutils literal notranslate"><span class="pre">ny</span></code> is set to <code class="docutils literal notranslate"><span class="pre">y.shape[0]</span></code> if it is
omitted (or negative).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.adapt_to_samples">
<span class="sig-name descname"><span class="pre">adapt_to_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nitn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nproc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.adapt_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapt map to data <code class="docutils literal notranslate"><span class="pre">{x,</span> <span class="pre">f(x)}</span></code>.</p>
<p>Replace grid with one that is optimized for integrating
function <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>. New grid is found iteratively</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em>) – <code class="docutils literal notranslate"><span class="pre">x[:,</span> <span class="pre">d]</span></code> are the components of the sample points
in direction <code class="docutils literal notranslate"><span class="pre">d=0,1...self.dim-1</span></code>.</p></li>
<li><p><strong>f</strong> (<em>callable</em><em> or </em><em>array</em>) – Function <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> to be adapted to. If
<code class="docutils literal notranslate"><span class="pre">f</span></code> is an array, it is assumes to contain values <code class="docutils literal notranslate"><span class="pre">f[i]</span></code>
corresponding to the function evaluated at points <code class="docutils literal notranslate"><span class="pre">x[i]</span></code>.</p></li>
<li><p><strong>nitn</strong> (<em>int</em>) – Number of iterations to use in adaptation. Default
is <code class="docutils literal notranslate"><span class="pre">nitn=5</span></code>.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Damping parameter for adaptation. Default
is <code class="docutils literal notranslate"><span class="pre">alpha=1.0</span></code>. Smaller values slow the iterative
adaptation, to improve stability of convergence.</p></li>
<li><p><strong>nproc</strong> (<em>int</em><em> or </em><em>None</em>) – <p>Number of processes/processors to use.
If <code class="docutils literal notranslate"><span class="pre">nproc&gt;1</span></code> Python’s <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> module is
used to spread the calculation across multiple processors.
There is a significant overhead involved in using
multiple processors so this option is useful mainly
when very high dimenions or large numbers of samples
are involved. When using the <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code>
module in its default mode for MacOS and Windows,
it is important that the main module can be
safely imported (i.e., without launching new
processes). This can be accomplished with
some version of the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__`:</span></code>
construct in the main module: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>This is not an issue on other Unix platforms.
See the <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> documentation
for more information.
Set <code class="docutils literal notranslate"><span class="pre">nproc=None</span></code> to use all the processors
on the machine (equivalent to <code class="docutils literal notranslate"><span class="pre">nproc=os.cpu_count()</span></code>).
Default value is <code class="docutils literal notranslate"><span class="pre">nproc=1</span></code>. (Requires Python 3.3 or later.)</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">x</span></code> values corresponding to <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">y</span></code> can be a single <code class="docutils literal notranslate"><span class="pre">dim</span></code>-dimensional point, or it
can be an array <code class="docutils literal notranslate"><span class="pre">y[i,j,</span> <span class="pre">...,</span> <span class="pre">d]</span></code> of such points (<code class="docutils literal notranslate"><span class="pre">d=0..dim-1</span></code>).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">y=None</span></code> (default), <code class="docutils literal notranslate"><span class="pre">y</span></code> is set equal to a (uniform) random point
in the volume.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.jac">
<span class="sig-name descname"><span class="pre">jac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the map’s Jacobian at <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">y</span></code> can be a single <code class="docutils literal notranslate"><span class="pre">dim</span></code>-dimensional point, or it
can be an array <code class="docutils literal notranslate"><span class="pre">y[i,j,...,d]</span></code> of such points (<code class="docutils literal notranslate"><span class="pre">d=0..dim-1</span></code>).
Returns an array <code class="docutils literal notranslate"><span class="pre">jac</span></code> where <code class="docutils literal notranslate"><span class="pre">jac[i,j,...]</span></code> is the
(multidimensional) Jacobian (<code class="docutils literal notranslate"><span class="pre">dx/dy</span></code>) corresponding
to <code class="docutils literal notranslate"><span class="pre">y[i,j,...]</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.jac1d">
<span class="sig-name descname"><span class="pre">jac1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.jac1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the map’s Jacobian at <code class="docutils literal notranslate"><span class="pre">y</span></code> for each direction.</p>
<p><code class="docutils literal notranslate"><span class="pre">y</span></code> can be a single <code class="docutils literal notranslate"><span class="pre">dim</span></code>-dimensional point, or it
can be an array <code class="docutils literal notranslate"><span class="pre">y[i,j,...,d]</span></code> of such points (<code class="docutils literal notranslate"><span class="pre">d=0..dim-1</span></code>).
Returns an array <code class="docutils literal notranslate"><span class="pre">jac</span></code> where <code class="docutils literal notranslate"><span class="pre">jac[i,j,...,d]</span></code> is the
(one-dimensional) Jacobian (<code class="docutils literal notranslate"><span class="pre">dx[d]/dy[d]</span></code>) corresponding
to <code class="docutils literal notranslate"><span class="pre">y[i,j,...,d]</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.make_uniform">
<span class="sig-name descname"><span class="pre">make_uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ninc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.make_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the grid with a uniform grid.</p>
<p>The new grid has <code class="docutils literal notranslate"><span class="pre">ninc[d]</span></code>  (or <code class="docutils literal notranslate"><span class="pre">ninc</span></code>, if it is a number)
increments along each direction if <code class="docutils literal notranslate"><span class="pre">ninc</span></code> is specified.
If <code class="docutils literal notranslate"><span class="pre">ninc=None</span></code> (default), the new grid has the same number
of increments in each direction as the old grid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map y to x, where jac is the Jacobian  (<code class="docutils literal notranslate"><span class="pre">dx/dy</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code> is an array of <code class="docutils literal notranslate"><span class="pre">ny</span></code> <code class="docutils literal notranslate"><span class="pre">y</span></code>-values for direction <code class="docutils literal notranslate"><span class="pre">d</span></code>.
<code class="docutils literal notranslate"><span class="pre">x[j,</span> <span class="pre">d]</span></code> is filled with the corresponding <code class="docutils literal notranslate"><span class="pre">x</span></code> values,
and <code class="docutils literal notranslate"><span class="pre">jac[j]</span></code> is filled with the corresponding Jacobian
values. <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">jac</span></code> must be preallocated: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">jac</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>array</em>) – <code class="docutils literal notranslate"><span class="pre">y</span></code> values to be mapped. <code class="docutils literal notranslate"><span class="pre">y</span></code> is a contiguous
2-d array, where <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code> contains values for points
along direction <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p></li>
<li><p><strong>x</strong> (<em>array</em>) – Container for <code class="docutils literal notranslate"><span class="pre">x[j,</span> <span class="pre">d]</span></code> values corresponding
to <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code>. Must be a contiguous 2-d array.</p></li>
<li><p><strong>jac</strong> (<em>array</em>) – Container for Jacobian values <code class="docutils literal notranslate"><span class="pre">jac[j]</span></code> (<code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">dx/dy</span></code>)
corresponding to <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code>. Must be a contiguous 1-d array.</p></li>
<li><p><strong>ny</strong> (<em>int</em>) – Number of <code class="docutils literal notranslate"><span class="pre">y</span></code> points: <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code> for <code class="docutils literal notranslate"><span class="pre">d=0...dim-1</span></code>
and <code class="docutils literal notranslate"><span class="pre">j=0...ny-1</span></code>. <code class="docutils literal notranslate"><span class="pre">ny</span></code> is set to <code class="docutils literal notranslate"><span class="pre">y.shape[0]</span></code> if it is
omitted (or negative).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.invmap">
<span class="sig-name descname"><span class="pre">invmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.invmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Map x to y, where jac is the Jacobian (<code class="docutils literal notranslate"><span class="pre">dx/dy</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code> is an array of <code class="docutils literal notranslate"><span class="pre">ny</span></code> <code class="docutils literal notranslate"><span class="pre">y</span></code>-values for direction <code class="docutils literal notranslate"><span class="pre">d</span></code>.
<code class="docutils literal notranslate"><span class="pre">x[j,</span> <span class="pre">d]</span></code> is filled with the corresponding <code class="docutils literal notranslate"><span class="pre">x</span></code> values,
and <code class="docutils literal notranslate"><span class="pre">jac[j]</span></code> is filled with the corresponding Jacobian
values. <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">jac</span></code> must be preallocated: for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">jac</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array</em>) – <code class="docutils literal notranslate"><span class="pre">x</span></code> values to be mapped to <code class="docutils literal notranslate"><span class="pre">y</span></code>-space. <code class="docutils literal notranslate"><span class="pre">x</span></code>
is a contiguous 2-d array, where <code class="docutils literal notranslate"><span class="pre">x[j,</span> <span class="pre">d]</span></code> contains
values for points along direction <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p></li>
<li><p><strong>y</strong> (<em>array</em>) – Container for <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code> values corresponding
to <code class="docutils literal notranslate"><span class="pre">x[j,</span> <span class="pre">d]</span></code>. Must be a contiguous 2-d array</p></li>
<li><p><strong>jac</strong> (<em>array</em>) – Container for Jacobian values <code class="docutils literal notranslate"><span class="pre">jac[j]</span></code> (<code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">dx/dy</span></code>)
corresponding to <code class="docutils literal notranslate"><span class="pre">y[j,</span> <span class="pre">d]</span></code>. Must be a contiguous 1-d array</p></li>
<li><p><strong>nx</strong> (<em>int</em>) – Number of <code class="docutils literal notranslate"><span class="pre">x</span></code> points: <code class="docutils literal notranslate"><span class="pre">x[j,</span> <span class="pre">d]</span></code> for <code class="docutils literal notranslate"><span class="pre">d=0...dim-1</span></code>
and <code class="docutils literal notranslate"><span class="pre">j=0...nx-1</span></code>. <code class="docutils literal notranslate"><span class="pre">nx</span></code> is set to <code class="docutils literal notranslate"><span class="pre">x.shape[0]</span></code> if it is
omitted (or negative).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.show_grid">
<span class="sig-name descname"><span class="pre">show_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ngrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shrink</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.show_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Display plots showing the current grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ngrid</strong> (<em>int</em>) – The number of grid nodes in each
direction to include in the plot. The default is 40.</p></li>
<li><p><strong>axes</strong> – List of pairs of directions to use in
different views of the grid. Using <code class="docutils literal notranslate"><span class="pre">None</span></code> in
place of a direction plots the grid for only one
direction. Omitting <code class="docutils literal notranslate"><span class="pre">axes</span></code> causes a default
set of pairings to be used.</p></li>
<li><p><strong>shrink</strong> – Display entire range of each axis
if <code class="docutils literal notranslate"><span class="pre">False</span></code>; otherwise shrink range to include
just the nodes being displayed. The default is
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>plotter</strong> – <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code> plotter to use for plots; plots
are not displayed if set. Ignored if <code class="docutils literal notranslate"><span class="pre">None</span></code>, and
plots are displayed using <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.settings">
<span class="sig-name descname"><span class="pre">settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ngrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Create string with information about grid nodes.</p>
<p>Creates a string containing the locations of the nodes
in the map grid for each direction. Parameter
<code class="docutils literal notranslate"><span class="pre">ngrid</span></code> specifies the maximum number of nodes to print
(spread evenly over the grid).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.extract_grid">
<span class="sig-name descname"><span class="pre">extract_grid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.extract_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of lists specifying the map’s grid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.AdaptiveMap.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vegas.AdaptiveMap.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear information accumulated by <a class="reference internal" href="#vegas.AdaptiveMap.add_training_data" title="vegas.AdaptiveMap.add_training_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AdaptiveMap.add_training_data()</span></code></a>.</p>
</dd></dl>

</dd>
</dl>
</dd></dl>

</section>
<section id="pdfintegrator-objects">
<h2>PDFIntegrator Objects<a class="headerlink" href="#pdfintegrator-objects" title="Permalink to this heading">¶</a></h2>
<p>Expectation values using probability density functions defined by
collections of Gaussian random variables (see <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code>)
can be evaluated using the following
specialized integrator:</p>
<dl class="py class">
<dt class="sig sig-object py" id="vegas.PDFIntegrator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">PDFIntegrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">svdcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.PDFIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> integrator for PDF expectation values.</p>
<p>Given a multi-dimensional Gaussian distribtuion <code class="docutils literal notranslate"><span class="pre">g</span></code> (a collection
of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s), <code class="docutils literal notranslate"><span class="pre">PDFIntegrator</span></code> creates a <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
integrator that evaluates expectation values of arbitrary
functions <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> where <code class="docutils literal notranslate"><span class="pre">p</span></code> is a point in the parameter
space of the distribution. Typical usage is illustrated by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
<span class="n">g</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="n">g</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="s1">&#39;fb&#39;</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">)</span>

<span class="n">expval</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">PDFIntegrator</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="n">b</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;f(p)&gt; =&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Here dictionary <code class="docutils literal notranslate"><span class="pre">g</span></code> specifies a three-dimensional distribution
where the first two variables <code class="docutils literal notranslate"><span class="pre">g['a'][0]</span></code> and <code class="docutils literal notranslate"><span class="pre">g['a'][1]</span></code>
are Gaussian with means 10 and 2, respectively, and covariance
matrix [[1, 1.4], [1.4, 2.]]. The last variable <code class="docutils literal notranslate"><span class="pre">g['b']</span></code> is
uniformly distributed on interval [2.9, 3.1]. The result
is: <code class="docutils literal notranslate"><span class="pre">&lt;f(p)&gt;</span> <span class="pre">=</span> <span class="pre">30.233(14)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">PDFIntegrator</span></code> evaluates integrals of both <code class="docutils literal notranslate"><span class="pre">f(p)</span> <span class="pre">*</span> <span class="pre">pdf(p)</span></code>
and <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code>, where <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> is the probability density
function (PDF) associated with distribution <code class="docutils literal notranslate"><span class="pre">g</span></code>. The expectation
value of <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> is the ratio of these two integrals (so
<code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> need not be normalized). Integration variables
are chosen to optimize the integral, and the integrator is
pre-adapted to <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> (so it is often unnecessary to discard
early iterations). The result of a <code class="docutils literal notranslate"><span class="pre">PDFIntegrator</span></code> integration
has an extra attribute, <code class="docutils literal notranslate"><span class="pre">result.pdfnorm</span></code>, which is the
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> estimate of the integral over the PDF.</p>
<p>The default (Gaussian) PDF associated with <code class="docutils literal notranslate"><span class="pre">g</span></code> can be
replaced by an arbitrary PDF function <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code>, allowing
PDFIntegrator to be used for non-Gaussian distributions.
In such cases, Gaussian distribution <code class="docutils literal notranslate"><span class="pre">g</span></code> does not affect
the values of the integrals; it is used only
to optimize the integration variables, and pre-adapt the
integrator (and so affects the accuracy of the results).
Ideally <code class="docutils literal notranslate"><span class="pre">g</span></code> is an approximation to the real
distribution — for example, it could be the prior
in a Bayesian analysis, or the result of a least-squares
(or other peak-finding) analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>, array of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s, or dictionary whose values
are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that specifies the
multi-dimensional Gaussian distribution used to construct
the probability density function. The integration
variables are optimized for this function.</p></li>
<li><p><strong>pdf</strong> – If specified, <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> is used as the probability
density function rather than the Gaussian PDF
associated with <code class="docutils literal notranslate"><span class="pre">g</span></code>. The Gaussian PDF is used if
<code class="docutils literal notranslate"><span class="pre">pdf=None</span></code> (default). Note that PDFs need not
be normalized.</p></li>
<li><p><strong>adapt_to_pdf</strong> (<em>bool</em>) – <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts to the PDF
when <code class="docutils literal notranslate"><span class="pre">adapt_to_pdf=True</span></code> (default). <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts
to <code class="docutils literal notranslate"><span class="pre">pdf(p)</span> <span class="pre">*</span> <span class="pre">f(p)</span></code> when calculating the expectation
value of <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> if <code class="docutils literal notranslate"><span class="pre">adapt_to_pdf=False</span></code>.</p></li>
<li><p><strong>limit</strong> (<em>positive float</em>) – Limits the integrations to a finite
region of size <code class="docutils literal notranslate"><span class="pre">limit</span></code> times the standard deviation on
either side of the mean. This can be useful if the
functions being integrated misbehave for large parameter
values (e.g., <code class="docutils literal notranslate"><span class="pre">numpy.exp</span></code> overflows for a large range of
arguments). Default is <code class="docutils literal notranslate"><span class="pre">limit=100</span></code>.</p></li>
<li><p><strong>scale</strong> (<em>positive float</em>) – The integration variables are
rescaled to emphasize parameter values of order
<code class="docutils literal notranslate"><span class="pre">scale</span></code> times the standard deviation. The rescaling
does not change the value of the integral but it
can reduce uncertainties in the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> estimate.
Default is <code class="docutils literal notranslate"><span class="pre">scale=1.0</span></code>.</p></li>
<li><p><strong>svdcut</strong> (<em>non-negative float</em><em> or </em><em>None</em>) – If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, replace
correlation matrix of <code class="docutils literal notranslate"><span class="pre">g</span></code> with a new matrix whose
small eigenvalues are modified: eigenvalues smaller than
<code class="docutils literal notranslate"><span class="pre">svdcut</span></code> times the maximum eigenvalue <code class="docutils literal notranslate"><span class="pre">eig_max</span></code> are
replaced by <code class="docutils literal notranslate"><span class="pre">svdcut*eig_max</span></code>. This can ameliorate
problems caused by roundoff errors when inverting the
covariance matrix. It increases the uncertainty associated
with the modified eigenvalues and so is conservative.
Setting <code class="docutils literal notranslate"><span class="pre">svdcut=None</span></code> or <code class="docutils literal notranslate"><span class="pre">svdcut=0</span></code> leaves the
covariance matrix unchanged. Default is <code class="docutils literal notranslate"><span class="pre">svdcut=1e-15</span></code>.</p></li>
</ul>
</dd>
</dl>
<p>All other keyword parameters are passed on to the the underlying <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a>;
the <code class="docutils literal notranslate"><span class="pre">uses_jac</span></code> keyword is ignored.</p>
<dl>
<dt>Methods:</dt><dd><dl class="py method">
<dt class="sig sig-object py" id="vegas.PDFIntegrator.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pdf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adapt_to_pdf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveall</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.PDFIntegrator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate expectation value of function <code class="docutils literal notranslate"><span class="pre">f(p)</span></code>.</p>
<p>Uses module <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> to estimate the integral of
<code class="docutils literal notranslate"><span class="pre">f(p)</span></code> multiplied by the probability density function
associated with <code class="docutils literal notranslate"><span class="pre">g</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code>). At the same
time it integrates the PDF. The ratio of the two integrals
is the expectation value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>function</em>) – Function <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> to integrate. Integral is
the expectation value of the function with respect
to the distribution. The function can return a number,
an array of numbers, or a dictionary whose values are
numbers or arrays of numbers. Setting <code class="docutils literal notranslate"><span class="pre">f=None</span></code> means
that only the PDF is integrated. Integrals can be
substantially faster if <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> (and <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> if set)
are batch functions (see <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> documentation).</p></li>
<li><p><strong>pdf</strong> – If specified, <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> is used as the probability
density function rather than the Gaussian PDF
associated with <code class="docutils literal notranslate"><span class="pre">g</span></code>. The Gaussian PDF is used if
<code class="docutils literal notranslate"><span class="pre">pdf=None</span></code> (default). Note that PDFs need not
be normalized.</p></li>
<li><p><strong>adapt_to_pdf</strong> (<em>bool</em>) – <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts to the PDF
when <code class="docutils literal notranslate"><span class="pre">adapt_to_pdf=True</span></code> (default). <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adapts
to <code class="docutils literal notranslate"><span class="pre">pdf(p)</span> <span class="pre">*</span> <span class="pre">f(p)</span></code> if <code class="docutils literal notranslate"><span class="pre">adapt_to_pdf=False</span></code>.</p></li>
<li><p><strong>save</strong> (<em>str</em><em> or </em><em>file</em><em> or </em><em>None</em>) – <p>Writes <code class="docutils literal notranslate"><span class="pre">results</span></code> into pickle file specified
by <code class="docutils literal notranslate"><span class="pre">save</span></code> at the end of each iteration. For example, setting
<code class="docutils literal notranslate"><span class="pre">save='results.pkl'</span></code> means that the results returned by the last
vegas iteration can be reconstructed later using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
</pre></div>
</div>
<p>Ignored if <code class="docutils literal notranslate"><span class="pre">save=None</span></code> (default).</p>
</p></li>
<li><p><strong>saveall</strong> (<em>str</em><em> or </em><em>file</em><em> or </em><em>None</em>) – <p>Writes <code class="docutils literal notranslate"><span class="pre">(results,</span> <span class="pre">integrator)</span></code> into pickle
file specified by <code class="docutils literal notranslate"><span class="pre">saveall</span></code> at the end of each iteration. For example,
setting <code class="docutils literal notranslate"><span class="pre">saveall='allresults.pkl'</span></code> means that the results returned by
the last vegas iteration, together with a clone of the (adapted) integrator,
can be reconstructed later using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;allresults.pkl&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
    <span class="n">results</span><span class="p">,</span> <span class="n">integrator</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
</pre></div>
</div>
<p>Ignored if <code class="docutils literal notranslate"><span class="pre">saveall=None</span></code> (default).</p>
</p></li>
</ul>
</dd>
</dl>
<p>All other keyword arguments are passed on to a <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>
integrator; see the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> documentation for further information.</p>
</dd></dl>

</dd>
</dl>
</dd></dl>

</section>
<section id="other-objects-and-functions">
<h2>Other Objects and Functions<a class="headerlink" href="#other-objects-and-functions" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="vegas.RAvg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">RAvg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itn_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sum_neval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Running average of scalar-valued Monte Carlo estimates.</p>
<p>This class accumulates independent Monte Carlo
estimates (e.g., of an integral) and combines
them into a single average. It
is derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code> (from
the <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code> module if it is present) and
represents a Gaussian random variable.</p>
<p>Different estimates are weighted by their
inverse variances if parameter <code class="docutils literal notranslate"><span class="pre">weight=True</span></code>;
otherwise straight, unweighted averages are used.</p>
<dl>
<dt>Attributes and methods:</dt><dd><dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvg.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><a class="headerlink" href="#vegas.RAvg.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean value of the weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvg.sdev">
<span class="sig-name descname"><span class="pre">sdev</span></span><a class="headerlink" href="#vegas.RAvg.sdev" title="Permalink to this definition">¶</a></dt>
<dd><p>The standard deviation of the weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvg.chi2">
<span class="sig-name descname"><span class="pre">chi2</span></span><a class="headerlink" href="#vegas.RAvg.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><em>chi**2</em> of weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvg.dof">
<span class="sig-name descname"><span class="pre">dof</span></span><a class="headerlink" href="#vegas.RAvg.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom in weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvg.Q">
<span class="sig-name descname"><span class="pre">Q</span></span><a class="headerlink" href="#vegas.RAvg.Q" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Q</em> or <em>p-value</em> of weighted average’s <em>chi**2</em>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvg.itn_results">
<span class="sig-name descname"><span class="pre">itn_results</span></span><a class="headerlink" href="#vegas.RAvg.itn_results" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the results from each iteration.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvg.sum_neval">
<span class="sig-name descname"><span class="pre">sum_neval</span></span><a class="headerlink" href="#vegas.RAvg.sum_neval" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of integrand evaluations used in all iterations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvg.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvg.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add estimate <code class="docutils literal notranslate"><span class="pre">g</span></code> to the running average.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvg.summary">
<span class="sig-name descname"><span class="pre">summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvg.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble summary of results, iteration-by-iteration, into a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weighted</strong> (<em>bool</em>) – Display weighted averages of results from different
iterations if <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise show unweighted averages.
Default behavior is determined by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvg.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ravg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvg.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge results from <a class="reference internal" href="#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">RAvg</span></code></a> object <code class="docutils literal notranslate"><span class="pre">ravg</span></code> after results currently in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vegas.RAvgArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">RAvgArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'object'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itn_results=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sum_neval=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale=True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Running average of array-valued Monte Carlo estimates.</p>
<p>This class accumulates independent arrays of Monte Carlo
estimates (e.g., of an integral) and combines
them into an array of averages. It
is derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>. The array
elements are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s (from the <code class="docutils literal notranslate"><span class="pre">gvar</span></code> module if
present) and represent Gaussian random variables.</p>
<p>Different estimates are weighted by their
inverse covariance matrices if parameter <code class="docutils literal notranslate"><span class="pre">weight=True</span></code>;
otherwise straight, unweighted averages are used.</p>
<dl>
<dt>Attributes and methods:</dt><dd><dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgArray.chi2">
<span class="sig-name descname"><span class="pre">chi2</span></span><a class="headerlink" href="#vegas.RAvgArray.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><em>chi**2</em> of weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgArray.dof">
<span class="sig-name descname"><span class="pre">dof</span></span><a class="headerlink" href="#vegas.RAvgArray.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom in weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgArray.Q">
<span class="sig-name descname"><span class="pre">Q</span></span><a class="headerlink" href="#vegas.RAvgArray.Q" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Q</em> or <em>p-value</em> of weighted average’s <em>chi**2</em>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgArray.itn_results">
<span class="sig-name descname"><span class="pre">itn_results</span></span><a class="headerlink" href="#vegas.RAvgArray.itn_results" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the results from each iteration.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgArray.sum_neval">
<span class="sig-name descname"><span class="pre">sum_neval</span></span><a class="headerlink" href="#vegas.RAvgArray.sum_neval" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of integrand evaluations used in all iterations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvgArray.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgArray.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add estimate <code class="docutils literal notranslate"><span class="pre">g</span></code> to the running average.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvgArray.summary">
<span class="sig-name descname"><span class="pre">summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extended</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgArray.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble summary of results, iteration-by-iteration, into a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>extended</strong> (<em>bool</em>) – Include a table of final averages for every
component of the integrand if <code class="docutils literal notranslate"><span class="pre">True</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em>) – Display weighted averages of results from different
iterations if <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise show unweighted averages.
Default behavior is determined by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvgArray.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ravg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgArray.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge results from <a class="reference internal" href="#vegas.RAvgArray" title="vegas.RAvgArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">RAvgArray</span></code></a> object <code class="docutils literal notranslate"><span class="pre">ravg</span></code> after results currently in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vegas.RAvgDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">RAvgDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itn_results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sum_neval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Running average of dictionary-valued Monte Carlo estimates.</p>
<p>This class accumulates independent dictionaries of Monte Carlo
estimates (e.g., of an integral) and combines
them into a dictionary of averages. It
is derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.BufferDict</span></code>. The dictionary
values are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.</p>
<p>Different estimates are weighted by their
inverse covariance matrices if parameter <code class="docutils literal notranslate"><span class="pre">weight=True</span></code>;
otherwise straight, unweighted averages are used.</p>
<dl>
<dt>Attributes and methods:</dt><dd><dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgDict.chi2">
<span class="sig-name descname"><span class="pre">chi2</span></span><a class="headerlink" href="#vegas.RAvgDict.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><em>chi**2</em> of weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgDict.dof">
<span class="sig-name descname"><span class="pre">dof</span></span><a class="headerlink" href="#vegas.RAvgDict.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom in weighted average.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgDict.Q">
<span class="sig-name descname"><span class="pre">Q</span></span><a class="headerlink" href="#vegas.RAvgDict.Q" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Q</em> or <em>p-value</em> of weighted average’s <em>chi**2</em>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgDict.itn_results">
<span class="sig-name descname"><span class="pre">itn_results</span></span><a class="headerlink" href="#vegas.RAvgDict.itn_results" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the results from each iteration.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.RAvgDict.sum_neval">
<span class="sig-name descname"><span class="pre">sum_neval</span></span><a class="headerlink" href="#vegas.RAvgDict.sum_neval" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of integrand evaluations used in all iterations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvgDict.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgDict.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Augment buffer with data <code class="docutils literal notranslate"><span class="pre">v</span></code>, indexed by key <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">v</span></code> is either a scalar or a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> array (or a list or
other data type that can be changed into a numpy.array).
If <code class="docutils literal notranslate"><span class="pre">v</span></code> is a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> array, it can have any shape.</p>
<p>Same as <code class="docutils literal notranslate"><span class="pre">self[k]</span> <span class="pre">=</span> <span class="pre">v</span></code> except when <code class="docutils literal notranslate"><span class="pre">k</span></code> is already used in
<code class="docutils literal notranslate"><span class="pre">self</span></code>, in which case a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvgDict.summary">
<span class="sig-name descname"><span class="pre">summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extended</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgDict.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble summary of results, iteration-by-iteration, into a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>extended</strong> (<em>bool</em>) – Include a table of final averages for every
component of the integrand if <code class="docutils literal notranslate"><span class="pre">True</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em>) – Display weighted averages of results from different
iterations if <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise show unweighted averages.
Default behavior is determined by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vegas.RAvgDict.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ravg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.RAvgDict.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge results from <a class="reference internal" href="#vegas.RAvgDict" title="vegas.RAvgDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">RAvgDict</span></code></a> object <code class="docutils literal notranslate"><span class="pre">ravg</span></code> after results currently in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vegas.batchintegrand">
<span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">batchintegrand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.batchintegrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for batch integrand functions.</p>
<p>Applying <a class="reference internal" href="#vegas.batchintegrand" title="vegas.batchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.batchintegrand()</span></code></a> to a function <code class="docutils literal notranslate"><span class="pre">fcn</span></code> repackages
the function in a format that <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> can understand. Appropriate
functions take a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> array of integration points <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">d]</span></code>
as an argument, where <code class="docutils literal notranslate"><span class="pre">i=0...</span></code> labels the integration point and
<code class="docutils literal notranslate"><span class="pre">d=0...</span></code> labels direction, and return an array <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> of
integrand values (or arrays of integrand values) for the corresponding
points. The meaning of <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code> is unchanged by the decorator.</p>
<p>An example is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">batchintegrand</span>      <span class="c1"># or @vegas.lbatchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>for the two-dimensional integrand <img class="math" src="_images/math/84b2eb1fcb99afba0bb57bf5e59fd86a51e913f8.svg" alt="\exp(-x_0 - x_1)"/>.
When integrands have dictionary arguments <code class="docutils literal notranslate"><span class="pre">xd</span></code>, each element of the
dictionary has an extra index (on the left): <code class="docutils literal notranslate"><span class="pre">xd[key][:,</span> <span class="pre">...]</span></code>.</p>
<p><a class="reference internal" href="#vegas.lbatchintegrand" title="vegas.lbatchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.lbatchintegrand()</span></code></a> is the same as <a class="reference internal" href="#vegas.batchintegrand" title="vegas.batchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.batchintegrand()</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vegas.BatchIntegrand">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">BatchIntegrand</span></span><a class="headerlink" href="#vegas.BatchIntegrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for l-batch integrands.</p>
<p>Used by <a class="reference internal" href="#vegas.batchintegrand" title="vegas.batchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.batchintegrand()</span></code></a>.</p>
<p><a class="reference internal" href="#vegas.LBatchIntegrand" title="vegas.LBatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.LBatchIntegrand</span></code></a> is the same as
<a class="reference internal" href="#vegas.BatchIntegrand" title="vegas.BatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.BatchIntegrand</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vegas.rbatchintegrand">
<span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">rbatchintegrand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.rbatchintegrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#vegas.batchintegrand" title="vegas.batchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.batchintegrand()</span></code></a> but with batch indices on the right (not left).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vegas.RBatchIntegrand">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">RBatchIntegrand</span></span><a class="headerlink" href="#vegas.RBatchIntegrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#vegas.BatchIntegrand" title="vegas.BatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.BatchIntegrand</span></code></a> but with batch indices on the right (not left).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vegas.lbatchintegrand">
<span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">lbatchintegrand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.lbatchintegrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for batch integrand functions.</p>
<p>Applying <a class="reference internal" href="#vegas.batchintegrand" title="vegas.batchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.batchintegrand()</span></code></a> to a function <code class="docutils literal notranslate"><span class="pre">fcn</span></code> repackages
the function in a format that <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> can understand. Appropriate
functions take a <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> array of integration points <code class="docutils literal notranslate"><span class="pre">x[i,</span> <span class="pre">d]</span></code>
as an argument, where <code class="docutils literal notranslate"><span class="pre">i=0...</span></code> labels the integration point and
<code class="docutils literal notranslate"><span class="pre">d=0...</span></code> labels direction, and return an array <code class="docutils literal notranslate"><span class="pre">f[i]</span></code> of
integrand values (or arrays of integrand values) for the corresponding
points. The meaning of <code class="docutils literal notranslate"><span class="pre">fcn(x)</span></code> is unchanged by the decorator.</p>
<p>An example is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="nd">@vegas</span><span class="o">.</span><span class="n">batchintegrand</span>      <span class="c1"># or @vegas.lbatchintegrand</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>for the two-dimensional integrand <img class="math" src="_images/math/84b2eb1fcb99afba0bb57bf5e59fd86a51e913f8.svg" alt="\exp(-x_0 - x_1)"/>.
When integrands have dictionary arguments <code class="docutils literal notranslate"><span class="pre">xd</span></code>, each element of the
dictionary has an extra index (on the left): <code class="docutils literal notranslate"><span class="pre">xd[key][:,</span> <span class="pre">...]</span></code>.</p>
<p><a class="reference internal" href="#vegas.lbatchintegrand" title="vegas.lbatchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.lbatchintegrand()</span></code></a> is the same as <a class="reference internal" href="#vegas.batchintegrand" title="vegas.batchintegrand"><code class="xref py py-func docutils literal notranslate"><span class="pre">vegas.batchintegrand()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vegas.LBatchIntegrand">
<span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">LBatchIntegrand</span></span><a class="headerlink" href="#vegas.LBatchIntegrand" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#vegas.BatchIntegrand" title="vegas._vegas.BatchIntegrand"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchIntegrand</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vegas.ravg">
<span class="sig-prename descclassname"><span class="pre">vegas.</span></span><span class="sig-name descname"><span class="pre">ravg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reslist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vegas.ravg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create running average from list of <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> results.</p>
<p>This function is used to change how the weighted average of
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> results is calculated. For example, the following code
discards the first five results (where <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is still adapting)
and does an unweighted average of the last five:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>

<span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mf">16.</span>

<span class="n">itg</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">itg</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="n">ur</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">ravg</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">itn_results</span><span class="p">[</span><span class="mi">5</span><span class="p">:],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ur</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
</pre></div>
</div>
<p>The unweighted average can be useful because it is unbiased.
The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itn</span>   <span class="n">integral</span>        <span class="n">wgt</span> <span class="n">average</span>     <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">1.013</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>       <span class="mf">1.013</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">0.997</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>       <span class="mf">1.002</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>           <span class="mf">0.45</span>     <span class="mf">0.50</span>
  <span class="mi">3</span>   <span class="mf">1.021</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>       <span class="mf">1.0112</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>          <span class="mf">0.91</span>     <span class="mf">0.40</span>
  <span class="mi">4</span>   <span class="mf">0.9785</span><span class="p">(</span><span class="mi">97</span><span class="p">)</span>      <span class="mf">0.9980</span><span class="p">(</span><span class="mi">62</span><span class="p">)</span>          <span class="mf">2.84</span>     <span class="mf">0.04</span>
  <span class="mi">5</span>   <span class="mf">1.0067</span><span class="p">(</span><span class="mi">85</span><span class="p">)</span>      <span class="mf">1.0010</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>          <span class="mf">2.30</span>     <span class="mf">0.06</span>
  <span class="mi">6</span>   <span class="mf">0.9996</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>      <span class="mf">1.0006</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>          <span class="mf">1.85</span>     <span class="mf">0.10</span>
  <span class="mi">7</span>   <span class="mf">1.0020</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>      <span class="mf">1.0010</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span>          <span class="mf">1.54</span>     <span class="mf">0.16</span>
  <span class="mi">8</span>   <span class="mf">1.0051</span><span class="p">(</span><span class="mi">52</span><span class="p">)</span>      <span class="mf">1.0022</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>          <span class="mf">1.39</span>     <span class="mf">0.21</span>
  <span class="mi">9</span>   <span class="mf">1.0046</span><span class="p">(</span><span class="mi">47</span><span class="p">)</span>      <span class="mf">1.0029</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>          <span class="mf">1.23</span>     <span class="mf">0.27</span>
 <span class="mi">10</span>   <span class="mf">0.9976</span><span class="p">(</span><span class="mi">47</span><span class="p">)</span>      <span class="mf">1.0018</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>          <span class="mf">1.21</span>     <span class="mf">0.28</span>

<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">average</span>         <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">0.9996</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>      <span class="mf">0.9996</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>          <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.0020</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>      <span class="mf">1.0008</span><span class="p">(</span><span class="mi">48</span><span class="p">)</span>          <span class="mf">0.06</span>     <span class="mf">0.81</span>
  <span class="mi">3</span>   <span class="mf">1.0051</span><span class="p">(</span><span class="mi">52</span><span class="p">)</span>      <span class="mf">1.0022</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>          <span class="mf">0.19</span>     <span class="mf">0.83</span>
  <span class="mi">4</span>   <span class="mf">1.0046</span><span class="p">(</span><span class="mi">47</span><span class="p">)</span>      <span class="mf">1.0028</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>          <span class="mf">0.18</span>     <span class="mf">0.91</span>
  <span class="mi">5</span>   <span class="mf">0.9976</span><span class="p">(</span><span class="mi">47</span><span class="p">)</span>      <span class="mf">1.0018</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>          <span class="mf">0.31</span>     <span class="mf">0.87</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reslist</strong> (<em>list</em>) – List whose elements are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s, arrays of
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s, or dictionaries whose values are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or
arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s. Alternatively <code class="docutils literal notranslate"><span class="pre">reslist</span></code> can be
the object returned by a call to a
<a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.Integrator</span></code></a> object (i.e, an instance of
any of <a class="reference internal" href="#vegas.RAvg" title="vegas.RAvg"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvg</span></code></a>, <a class="reference internal" href="#vegas.RAvgArray" title="vegas.RAvgArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvgArray</span></code></a>,
<a class="reference internal" href="#vegas.RAvgArray" title="vegas.RAvgArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.RAvgArray</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFRAvg</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFRAvgArray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">vegas.PDFRAvgArray</span></code>).</p></li>
<li><p><strong>weighted</strong> (<em>bool</em>) – Running average is weighted (by the inverse
covariance matrix) if <code class="docutils literal notranslate"><span class="pre">True</span></code>. Otherwise the
average is unweighted, which makes most sense if <code class="docutils literal notranslate"><span class="pre">reslist</span></code>
items were generated by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> with little or no
adaptation (e.g., with <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code>). If <code class="docutils literal notranslate"><span class="pre">weighted</span></code>
is not specified (or is <code class="docutils literal notranslate"><span class="pre">None</span></code>), it is set equal to
<code class="docutils literal notranslate"><span class="pre">getattr(reslist,</span> <span class="pre">'weighted',</span> <span class="pre">True)</span></code>.</p></li>
<li><p><strong>rescale</strong> – Integration results are divided by <code class="docutils literal notranslate"><span class="pre">rescale</span></code>
before taking the weighted average if
<code class="docutils literal notranslate"><span class="pre">weighted=True</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">rescale</span></code> is ignored.
Setting <code class="docutils literal notranslate"><span class="pre">rescale=True</span></code> is equivalent to setting
<code class="docutils literal notranslate"><span class="pre">rescale=reslist[-1]</span></code>. If <code class="docutils literal notranslate"><span class="pre">rescale</span></code> is not
specified (or is <code class="docutils literal notranslate"><span class="pre">None</span></code>), it is set equal to
<code class="docutils literal notranslate"><span class="pre">getattr(reslist,</span> <span class="pre">'rescale',</span> <span class="pre">True)</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> Module</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#integrator-objects">Integrator Objects</a></li>
<li><a class="reference internal" href="#adaptivemap-objects">AdaptiveMap Objects</a></li>
<li><a class="reference internal" href="#pdfintegrator-objects">PDFIntegrator Objects</a></li>
<li><a class="reference internal" href="#other-objects-and-functions">Other Objects and Functions</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="outliers.html"
                          title="previous chapter">Case Study: Bayesian Curve Fitting</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/vegas.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="outliers.html" title="Case Study: Bayesian Curve Fitting"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">vegas 5.6 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> Module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2023, G. P. Lepage.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>